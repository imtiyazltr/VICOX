local WindUI

do
    local ok, result = pcall(function()
        return require("./src/Init")
    end)
    
    if ok then
        WindUI = result
    else 
        WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
    end
end


-- Roblox Services
local RobloxReplicatedStorage = cloneref(game:GetService('RobloxReplicatedStorage'))
local RbxAnalyticsService = cloneref(game:GetService('RbxAnalyticsService'))
local ReplicatedStorage = cloneref(game:GetService('ReplicatedStorage'))
local UserInputService = cloneref(game:GetService('UserInputService'))
local NetworkClient = cloneref(game:GetService("NetworkClient"))
local TweenService = cloneref(game:GetService('TweenService'))
local VirtualUser = cloneref(game:GetService('VirtualUser'))
local HttpService = cloneref(game:GetService('HttpService'))
local RunService = cloneref(game:GetService('RunService'))
local LogService = cloneref(game:GetService('LogService'))
local Lighting = cloneref(game:GetService('Lighting'))
local CoreGui = cloneref(game:GetService('CoreGui'))
local Players = cloneref(game:GetService('Players'))
local Debris = cloneref(game:GetService('Debris'))
local Stats = cloneref(game:GetService('Stats'))
local CollectionService = game:GetService("CollectionService")
local VirtualInputManager = cloneref(game:GetService("VirtualInputManager"))
local Workspace = cloneref(game:GetService('Workspace'))
local ContentProvider = cloneref(game:GetService("ContentProvider"))

if not game:IsLoaded() then
    game.Loaded:Wait()
end

local success, result = pcall(function()
    loadstring(game:GetObjects("rbxassetid://15900013841")[1].Source)()
end)
if not success then
    WindUI:Notify({
        Title = "Anti-Cheat Bypass",
        Content = "Failed to load bypass: " .. tostring(result),
        Duration = 4,
        Icon = "rotate-cw"
    })
else
    WindUI:Notify({
        Title = "Anti-Cheat Bypass",
        Content = "Bypass loaded successfully!",
        Duration = 4,
        Icon = "rotate-cw"
    })
end

setfpscap(120)

type functionInfo = {
    scriptName: string,
    name: string,
    line: number,
    upvalueCount: number,
    constantCount: number
}

local function getFunction(t:functionInfo)
    t = t or {}
    local functions = {}
    local function findMatches()
        setthreadidentity(6)
        for i,v in getgc() do
            if type(v) == "function" and islclosure(v) then
                local match = true
                local info = getinfo(v)
                if t.scriptName and (not tostring(getfenv(v).script):find(t.scriptName)) then
                    match = false
                end
                if t.name and info.name ~= t.name then
                    match = false
                end
                if t.line and info.currentline ~= t.line then
                    match = false
                end
                if t.upvalueCount and #getupvalues(v) ~= t.upvalueCount then
                    match = false
                end
                if t.constantCount and #getconstants(v) ~= t.constantsCount then
                    match = false
                end
                if match then
                    table.insert(functions,v)
                end
            end
        end
        setthreadidentity(8)
    end

    findMatches()

    if #functions == 0 then
        while task.wait(1) and #functions == 0 do
            findMatches()
        end
    end
    
    if #functions == 1 then
        return functions[1]
    end
end

type tableInfo = {
    highEntropyTableIndex: string,
}

if getgenv().updateSword and getgenv().skinChanger then
    getgenv().updateSword()
    return
end

local function getTable(t)
    t = t or {}
    local tables = {}
    
    local function findMatches()
        for i, v in getgc(true) do
            if type(v) == "table" then
                local match = true
                if t.highEntropyTableIndex and (not rawget(v, t.highEntropyTableIndex)) then
                    match = false
                end
                if match then
                    table.insert(tables, v)
                end
            end
        end
    end

    findMatches()

    if #tables == 0 then
        while task.wait(1) and #tables == 0 do
            findMatches()
        end
    end

    if #tables == 1 then
        return tables[1]
    end
end

local plrs = game:GetService("Players")
local plr = plrs.LocalPlayer
local rs = game:GetService("ReplicatedStorage")
local swordInstancesInstance = rs:WaitForChild("Shared", 9e9):WaitForChild("ReplicatedInstances", 9e9):WaitForChild("Swords", 9e9)
local swordInstances = require(swordInstancesInstance)

local swordsController
while task.wait() and (not swordsController) do
    for i, v in getconnections(rs.Remotes.FireSwordInfo.OnClientEvent) do
        if v.Function and islclosure(v.Function) then
            local upvalues = getupvalues(v.Function)
            if #upvalues == 1 and type(upvalues[1]) == "table" then
                swordsController = upvalues[1]
                break
            end
        end
    end
end

local function getSlashName(swordName)
    local slashName = swordInstances:GetSword(swordName)
    return (slashName and slashName.SlashName) or "SlashEffect"
end

local function setSword()
    if not getgenv().skinChanger then return end
    
    local success, err = pcall(function()
        setupvalue(rawget(swordInstances, "EquipSwordTo"), 2, false)
        swordInstances:EquipSwordTo(plr.Character, getgenv().swordModel)
        swordsController:SetSword(getgenv().swordAnimations)
    end)
    if not success then
        WindUI:Notify({
            Title = "Skin Changer Error",
            Content = "Failed to set sword: " .. tostring(err),
            Duration = 5,
            Icon = "alert-triangle"
        })
    end
end

local playParryFunc
local parrySuccessAllConnection
while task.wait() and not parrySuccessAllConnection do
    for i, v in getconnections(rs.Remotes.ParrySuccessAll.OnClientEvent) do
        if v.Function and getinfo(v.Function).name == "parrySuccessAll" then
            parrySuccessAllConnection = v
            playParryFunc = v.Function
            v:Disable()
        end
    end
end

local parrySuccessClientConnection
while task.wait() and not parrySuccessClientConnection do
    for i, v in getconnections(rs.Remotes.ParrySuccessClient.Event) do
        if v.Function and getinfo(v.Function).name == "parrySuccessAll" then
            parrySuccessClientConnection = v
            v:Disable()
        end
    end
end

getgenv().slashName = getSlashName(getgenv().swordFX)

local lastOtherParryTimestamp = 0
local clashConnections = {}

rs.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(...)
    setthreadidentity(2)
    local args = {...}
    if tostring(args[4]) ~= plr.Name then
        lastOtherParryTimestamp = tick()
    elseif getgenv().skinChanger then
        args[1] = getgenv().slashName
        args[3] = getgenv().swordFX
    end
    return playParryFunc(unpack(args))
end)

table.insert(clashConnections, getconnections(rs.Remotes.ParrySuccessAll.OnClientEvent)[1])

getgenv().updateSword = function()
    getgenv().slashName = getSlashName(getgenv().swordFX)
    setSword()
end

task.spawn(function()
    while task.wait(1) do
        if getgenv().skinChanger then
            local char = plr.Character or plr.CharacterAdded:Wait()
            if plr:GetAttribute("CurrentlyEquippedSword") ~= getgenv().swordModel then
                setSword()
            end
            if char and (not char:FindFirstChild(getgenv().swordModel)) then
                setSword()
            end
            for _, v in (char and char:GetChildren()) or {} do
                if v:IsA("Model") and v.Name ~= getgenv().swordModel then
                    v:Destroy()
                end
                task.wait()
            end
        end
    end
end)

local LocalPlayer = Players.LocalPlayer

local SelectedParryMethod = "Hook"

-- Define Config table once
local Config = {       
    plushie_enabled = false, 
    plushie_type = "Miku", 
    visual_ring = false,    
    manual_spam = false, 
    auto_parry = true,
    auto_spam_parry = false,
    auto_parry_rotation = false,
    lobby_auto_parry = true,
    auto_parry_rotation_acuity = 5,
    curve_method = "Normal",
    no_slow = false,
    no_render = false,
    smart_no_render = false,
    sound_effect_enabled = false,
    night_mode = false,
    strafe = 5,
    strafe_speed = 50,
    personnel_detector = false,
    personnel_detector_auto_leave = true,
    auto_particles = false,
    screen_enabled = true,
    field = false,
    field_of_view = 0,
    camera = false,
    ability_vulnerability = true,
    mode = "Quad Jump",
    animations = false,
    smart_animations = false,
    animation_type = "None",
    manual_spam = false,
    ai_play = false,
    ai_method = "AdvancedPro",    
    ball_text_enabled = false,
    player_text_enabled = false,
    swordModel = "",
    swordAnimations = "",
    swordFX = "",
    plushieEnabled = false,
    plushieType = "",
    visualize_Enabled = false,
    visuals_enabled = true,
    player_follow = false,
    follow_target = nil, 
    color_shift = false, 
    shaders = false, 
    shaders_intensity = 150, 
    shaders_size = 78.54, 
    shaders_threshold = 236.25, 
    environment_specular_scale = 50, 
    environment_diffuse_scale = 50, 
    ray_tracing = false, 
    ambient = false, 
    ambient_density = 50,   
    disable_quantum_effects = false,
    auto_rewards = false, 
    disable_quantum_effects = false, 
    slashes_of_fury_enabled = false, 
    slashes_of_fury_mode = "Blatant", 
    animations = false, 
    visualize = true, 
    triggerbot = false, 
    ping_booster = false, 
    self_effect = true,
    self_effect_selected = "Magic Circle", 
    kill_effect = false, 
    ball_trail_enabled = false, -- Existing: Enable/disable ball trail
    ball_trail_color = Color3.fromRGB(255, 0, 0), -- Existing: Ball trail color
    player_trail_enabled = false, -- Existing: Enable/disable player trail
    player_trail_color = Color3.fromRGB(0, 255, 255), -- Existing: Player trail color
    trail_particle_enabled = false, -- New: Enable/disable particle effect on trails
    trail_particle_rate = 10, -- New: Particle emission rate (particles per second)
    trail_animation_type = "Pulse", -- New: Trail animation type (Static, Pulse, Flicker)
    trail_texture = "None",
    kill_effect = false,
    kill_effect_scale = 1,
    kill_effect_animation = "Spiral"
}


if getgenv and type(getgenv) == "function" then
    pcall(function()
        getgenv().Config = Config
    end)
else
    warn("getgenv() not supported by this executor. Using local Config. [Bro I Said U Have To Use High Unc]")
end
 

-- Check if getgenv exists and is a function
if getgenv and type(getgenv) == "function" then
    pcall(function()
        -- Assign all top-level variables to getgenv with their original names
        getgenv().AIPlaying = false
        getgenv().AICoroutine = nil
        getgenv().AITarget = nil
        getgenv().AICurrentMethod = "AdvancedPro"
        getgenv().AIStuckCheck = {
            lastPosition = Vector3.new(),
            checkTime = 0,
            stuckDuration = 0
        }
        getgenv().AICooldowns = {
            jump = 0,
            dash = 0,
            targetSwitch = 0,
            action = 0
        }
        getgenv().BallTrail = nil
        getgenv().PlayerTrail = nil
        getgenv().TrailConnection = nil
        getgenv().lastTrailUpdateTime = 0
        getgenv().BallBillboard = nil
        getgenv().PlayerBillboard = nil
        getgenv().lastUpdateTime = 0
        getgenv().ballBillboardEnabled = false
        getgenv().playerBillboardEnabled = false
        getgenv().AutoPlayModule = {
            CONFIG = {
                DEFAULT_DISTANCE = 30,
                MULTIPLIER_THRESHOLD = 70,
                TRAVERSING = 25,
                DIRECTION = 1,
                JUMP_PERCENTAGE = 50,
                DOUBLE_JUMP_PERCENTAGE = 50,
                JUMPING_ENABLED = false,
                MOVEMENT_DURATION = 0.8,
                OFFSET_FACTOR = 0.7,
                GENERATION_THRESHOLD = 0.25
            },
            ball = nil,
            lobbyChoice = nil,
            animationCache = nil,
            doubleJumped = false,
            ELAPSED = 0,
            CONTROL_POINT = nil,
            LAST_GENERATION = 0,
            signals = {}
        }
        getgenv().updateBillboardText = nil
        getgenv().TargetSelectionMethod = "ClosestToCursor"
        getgenv().RunTime = workspace.Runtime
        getgenv().Alive = workspace.Alive
        getgenv().Dead = workspace.Dead
        getgenv().AutoParry = {
            ball = {
                training_ball_entity = nil,
                client_ball_entity = nil,
                ball_entity = nil,
                properties = {
                    aero_dynamic_time = tick(),
                    hell_hook_completed = true,
                    last_position = Vector3.zero,
                    rotation = Vector3.zero,
                    position = Vector3.zero,
                    last_warping = tick(),               
                    is_curveds = false,
                    is_curved = false,
                    last_tick = tick(),
                    auto_spam = false,
                    cooldown = false,
                    respawn_time = 0,
                    parry_range = 1,
                    spam_range = 0,        
                    maximum_speed = 0,
                    old_speed = 0,
                    parries = 0,
                    direction = 0,
                    distance = 0,
                    velocity = 0,
                    last_hit = 0,
                    lerp_radians = 0,
                    radians = 0,
                    speed = 0,
                    prev_speed = 0,
                    dot = 0,
                    curve_history = {}
                }
            },
            target = {
                current = nil,
                current_changed = false,  
                direction_changed_on_cframe = false,
                from = nil,
                aim = nil,
            },
            entity_properties = {
                server_position = Vector3.zero,
                velocity = Vector3.zero,
                is_moving = false,
                direction = 0,
                distance = 0,
                speed = 0,
                dot = 0
            }
        }
        getgenv().Player = {
            Entity = {
                properties = {
                    sword = '',
                    server_position = Vector3.zero,
                    velocity = Vector3.zero,
                    position = Vector3.zero,
                    is_moving = false,
                    is_moving_backwards = false,
                    speed = 0,
                    ping = 0
                }
            },
            properties = {
                grab_animation = nil
            }
        }
        getgenv().World = {}
        getgenv().parry_mode = "Blatant"
        getgenv().auto_farm_enabled = false
        getgenv().auto_farm_type = "Random Orbit"
        getgenv().auto_farm_orbit = 5
        getgenv().auto_farm_height = 10
        getgenv().auto_farm_radius = 20
        getgenv().cameraViewMode = "ThirdPerson"
        getgenv().Camera = Workspace.CurrentCamera
        getgenv().visualizerEnabled = false
        getgenv().cameraLocked = false
        getgenv().cameraConnection = nil
    end)
else
    warn("getgenv() not supported by this executor. Using local variables. [Bro I Said U Have To Use High Unc]")
end


local AIPlaying = false
local AICoroutine = nil
local AITarget = nil
local AICurrentMethod = "AdvancedPro"
local AIStuckCheck = {
    lastPosition = Vector3.new(),
    checkTime = 0,
    stuckDuration = 0
}
local AICooldowns = {
    jump = 0,
    dash = 0,
    targetSwitch = 0,
    action = 0
}

-- Trail Management
local BallTrail = nil
local PlayerTrail = nil
local TrailConnection = nil
local lastTrailUpdateTime = 0 -- For throttling updates

local BallBillboard = nil
local PlayerBillboard = nil
local lastUpdateTime = 0

local ballBillboardEnabled = false
local playerBillboardEnabled = false

local AutoPlayModule = {}
    AutoPlayModule.CONFIG = {
        DEFAULT_DISTANCE = 30,
        MULTIPLIER_THRESHOLD = 70,
        TRAVERSING = 25,
        DIRECTION = 1,
        JUMP_PERCENTAGE = 50,
        DOUBLE_JUMP_PERCENTAGE = 50,
        JUMPING_ENABLED = false,
        MOVEMENT_DURATION = 0.8,
        OFFSET_FACTOR = 0.7,
        GENERATION_THRESHOLD = 0.25
    }
    
    AutoPlayModule.ball = nil
    AutoPlayModule.lobbyChoice = nil
    AutoPlayModule.animationCache = nil
    AutoPlayModule.doubleJumped = false
    AutoPlayModule.ELAPSED = 0
    AutoPlayModule.CONTROL_POINT = nil
    AutoPlayModule.LAST_GENERATION = 0
    AutoPlayModule.signals = {}

local updateBillboardText = nil

local TargetSelectionMethod = "ClosestToCursor"

local RunTime = workspace.Runtime
local Alive = workspace.Alive
local Dead = workspace.Dead

-- AutoParry and Player data structures
local AutoParry = {
    ball = nil,
    target = nil,
    entity_properties = nil
}

local Player = {
    Entity = nil,
    properties = {
        grab_animation = nil
    }
}

Player.Entity = {
    properties = {
        sword = '',
        server_position = Vector3.zero,
        velocity = Vector3.zero,
        position = Vector3.zero,
        is_moving = false,
        is_moving_backwards = false,
        speed = 0,
        ping = 0
    }
}

local World = {}

AutoParry.ball = {
    training_ball_entity = nil,
    client_ball_entity = nil,
    ball_entity = nil,
    properties = {
        aero_dynamic_time = tick(),
        firstParryFired = false,
        hell_hook_completed = true,
        last_position = Vector3.zero,
        rotation = Vector3.zero,
        position = Vector3.zero,
        last_warping = tick(),    
        curve_chance = 0,           
        is_curveds = false,
        is_curved = false,
        last_tick = tick(),
        auto_spam = false,
        cooldown = false,
        respawn_time = 0,
        parry_range = 1,
        spam_range = 0,        
        maximum_speed = 0,
        old_speed = 0,
        parries = 0,
        direction = 0,
        distance = 0,
        velocity = 0,
        last_hit = 0,
        lerp_radians = 0,
        prev_radians = 0,
        radians = 0,
        speed = 0,
        prev_speed = 0,
        dot = 0,
        curve_history = {}
    }
}

AutoParry.target = {
    current = nil,
    current_changed = false,  
    direction_changed_on_cframe = false,
    from = nil,
    aim = nil,
}

AutoParry.entity_properties = {
    server_position = Vector3.zero,
    velocity = Vector3.zero,
    is_moving = false,
    direction = 0,
    distance = 0,
    speed = 0,
    dot = 0
}


local parry_mode = "Blatant"
local auto_farm_enabled = false
local auto_farm_type = "Random Orbit"
local auto_farm_orbit = 5
local auto_farm_height = 10
local auto_farm_radius = 20
local cameraViewMode = "ThirdPerson"
local Camera = Workspace.CurrentCamera
local visualizerEnabled = false
local cameraLocked = false
local cameraConnection = nil

getgenv().AnimationsEnabled = false
getgenv().BallDirectionIndicator = true
getgenv().speeddo = 2
getgenv().WorldFilterEnabled = false
getgenv().AtmosphereEnabled = false
getgenv().FogEnabled = false
getgenv().SaturationEnabled = false
getgenv().HueEnabled = false
getgenv().skinChanger = false
getgenv().swordModel = ""
getgenv().swordAnimations = ""
getgenv().swordFX = ""

local skyboxData = {
    ["Default"] = {"591058823", "591059876", "591058104", "591057861", "591057625", "591059642"},
    ["Vaporwave"] = {"1417494030", "1417494146", "1417494253", "1417494402", "1417494499", "1417494643"},
    ["Redshift"] = {"401664839", "401664862", "401664960", "401664881", "401664901", "401664936"},
    ["Desert"] = {"1013852", "1013853", "1013850", "1013851", "1013849", "1013854"},
    ["DaBaby"] = {"7245418472", "7245418472", "7245418472", "7245418472", "7245418472", "7245418472"},
    ["Minecraft"] = {"1876545003", "1876544331", "1876542941", "1876543392", "1876543764", "1876544642"},
    ["SpongeBob"] = {"7633178166", "7633178166", "7633178166", "7633178166", "7633178166", "7633178166"},
    ["Skibidi"] = {"14952256113", "14952256113", "14952256113", "14952256113", "14952256113", "14952256113"},
    ["Blaze"] = {"150939022", "150939038", "150939047", "150939056", "150939063", "150939082"},
    ["Pussy Cat"] = {"11154422902", "11154422902", "11154422902", "11154422902", "11154422902", "11154422902"},
    ["Among Us"] = {"5752463190", "5752463190", "5752463190", "5752463190", "5752463190", "5752463190"},
    ["Space Wave"] = {"16262356578", "16262358026", "16262360469", "16262362003", "16262363873", "16262366016"},
    ["Space Wave2"] = {"1233158420", "1233158838", "1233157105", "1233157640", "1233157995", "1233159158"},
    ["Turquoise Wave"] = {"47974894", "47974690", "47974821", "47974776", "47974859", "47974909"},
    ["Dark Night"] = {"6285719338", "6285721078", "6285722964", "6285724682", "6285726335", "6285730635"},
    ["Bright Pink"] = {"271042516", "271077243", "271042556", "271042310", "271042467", "271077958"},
    ["White Galaxy"] = {"5540798456", "5540799894", "5540801779", "5540801192", "5540799108", "5540800635"},
    ["Blue Galaxy"] = {"14961495673", "14961494492", "14961492844", "14961491298", "14961490439", "14961489508"}
}


local soundOptions = {
    ["back it up"] = "rbxassetid://16190782181",
    ["Sweep"] = "rbxassetid://103508936658553",
    ["Bounce"] = "rbxassetid://134818882821660",
    ["Everybody Wants To Rule The World"] = "rbxassetid://87209527034670",
    ["Missing Money"] = "rbxassetid://134668194128037",
    ["Sour Grapes"] = "rbxassetid://117820392172291",
    ["Erwachen"] = "rbxassetid://124853612881772",
    ["Grasp the Light"] = "rbxassetid://89549155689397",
    ["Beyond the Shadows"] = "rbxassetid://120729792529978",
    ["Rise to the Horizon"] = "rbxassetid://72573266268313",
    ["Echoes of the Candy Kingdom"] = "rbxassetid://103040477333590",
    ["Speed"] = "rbxassetid://125550253895893",
    ["Lo-fi Chill A"] = "rbxassetid://9043887091",
    ["Lo-fi Ambient"] = "rbxassetid://129775776987523",
    ["Tears in the Rain"] = "rbxassetid://129710845038263"
}

local currentSound = Instance.new("Sound")
currentSound.Name = "BackgroundMusic"
currentSound.Volume = 2
currentSound.Looped = false
currentSound.Parent = game:GetService("SoundService")

local selectedSound = "back it up"
local MarketplaceService = game:GetService("MarketplaceService")

-- Validasi Sound ID
local function isValidSoundId(soundId)
    local success, info = pcall(function()
        local id = string.match(soundId, "%d+")
        if not id then return false end
        local assetInfo = MarketplaceService:GetProductInfo(id)
        return assetInfo.AssetTypeId == 3
    end)
    return success and info
end

-- Play Sound (adaptasi playSoundById)
local function playSound()
    local soundId = soundOptions[selectedSound]
    if not soundId then
        WindUI:Notify({
            Title = "Music Error",
            Content = "No sound ID for " .. selectedSound,
            Duration = 5,
            Icon = "warning"
        })
        return
    end
    if isValidSoundId(soundId) then
        currentSound:Stop()
        currentSound.SoundId = soundId
        currentSound:Play()
        WindUI:Notify({
            Title = "Background Music",
            Content = "Playing " .. selectedSound,
            Duration = 5,
            Icon = "music"
        })
    else
        WindUI:Notify({
            Title = "Music Error",
            Content = "Failed to load " .. selectedSound .. " (Invalid or Unreviewed)",
            Duration = 5,
            Icon = "warning"
        })
    end
end

local CURVE_HISTORY_SIZE = 5

local Parry_Remote = nil
local Parry_Key = nil
local Parry_Keys = nil
local Parry_Arg = nil

task.spawn(function()
    if SelectedParryMethod == "getgc" then
        for _, value in getgc() do
            if type(value) == "function" and islclosure(value) then
                local protos = debug.getprotos(value)
                local upvalues = debug.getupvalues(value)
                local constants = debug.getconstants(value)
                if #protos == 4 and #upvalues == 24 and #constants >= 102 then
                    Parry_Key = debug.getupvalue(value, 17)
                    Parry_Remote = debug.getupvalue(value, 18)
                    Parry_Arg = debug.getconstant(value, 64)
                    break
                end
            end
        end
    end
end)

local function VicoX(...)
    local Hash = (Parry_Arg and string.match(Parry_Arg, "PARRY_HASH_FAKE")) and nil or Parry_Arg
    Parry_Remote:FireServer(Hash, Parry_Key, ...)
end

local revertedRemotes = {}
local originalMetatables = {}

local function isValidRemoteArgs(args)
    return #args == 7 and
           type(args[2]) == "string" and  
           type(args[3]) == "number" and 
           typeof(args[4]) == "CFrame" and 
           type(args[5]) == "table" and  
           type(args[6]) == "table" and 
           type(args[7]) == "boolean"
end

local function hookRemote(remote)
    if not revertedRemotes[remote] then
        local meta = getrawmetatable(remote)
        if not originalMetatables[meta] then
            originalMetatables[meta] = true  
            setreadonly(meta, false)  

            local oldIndex = meta.__index
            meta.__index = function(self, key)
                if key == "FireServer" and self:IsA("RemoteEvent") then
                    return function(_, ...)
                        local args = { ... }
                        if isValidRemoteArgs(args) then
                            if not revertedRemotes[self] then
                                revertedRemotes[self] = args
                            end
                        end
                        return oldIndex(self, "FireServer")(_, table.unpack(args))
                    end
                elseif key == "InvokeServer" and self:IsA("RemoteFunction") then
                    return function(_, ...)
                        local args = { ... }
                        if isValidRemoteArgs(args) then
                            if not revertedRemotes[self] then
                                revertedRemotes[self] = args
                                print("Hooked RemoteFunction:", self.Name)
                            end
                        end
                        return oldIndex(self, "InvokeServer")(_, table.unpack(args))
                    end
                end
                return oldIndex(self, key)
            end

            setreadonly(meta, true)
        end
    end
end

local function restoreRemotes()
    for remote, _ in pairs(revertedRemotes) do
        if originalMetatables[getmetatable(remote)] then
            local meta = getrawmetatable(remote)
            setreadonly(meta, false)
            meta.__index = nil
            setreadonly(meta, true)
        end
    end
    revertedRemotes = {}
end

for _, remote in pairs(game.ReplicatedStorage:GetChildren()) do
    if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
        hookRemote(remote)
    end
end

game.ReplicatedStorage.ChildAdded:Connect(function(child)
    if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
        hookRemote(child)
    end
end)

function gradient(text, startColor, endColor)
    local result = ""
    local length = #text

    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)

        local char = text:sub(i, i)
        result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
    end

    return result
end

local Confirmed = false

WindUI:Popup({
    Title = "VicoXBladeBall (Premium-Moderate)",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Content = "Welcome VicoMem!" .. gradient("\nVicoX", Color3.fromHex("#00FF87"), Color3.fromHex("#60EFFF")) .. "\n#1 On Top..",
    Buttons = {
        {
            Title = "Cancel",
            Icon = "sword",
            Callback = function() end,
            Variant = "Primary",
        },
        {
            Title = "Continue",
            Icon = "arrow-right",
            Callback = function() Confirmed = true end,
            Variant = "Tertiary",
        }
    }
})

repeat wait() until Confirmed

local Window = WindUI:CreateWindow({
    Title = "VicoX",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Author = "Rudert",
    Folder = "VicoXAmbatublow",
    Size = UDim2.fromOffset(350, 350),
    Transparent = true,
    Theme = "Dark",
    User = {
        Enabled = true,
        Callback = function() print("clicked") end,
        Anonymous = false
    },
    SideBarWidth = 200,
    HideSearchBar = false, -- hides searchbar
    ScrollBarEnabled = true, -- enables scrollbar    
    
    KeySystem = {
        Key = { "Testing-You", "OnlyOwnerWhoKnows" },
        Note = "Key Is = Testing-You. Don't Worry Just.. Put it And Play As You Want.",
        Thumbnail = {
        Image = "rbxassetid://18220445082",
            Title = "#BladeBall \n\n#VicoXOnTop"
        },
        URL = "https://discord.gg/pbUCMc8VFs",
        SaveKey = true,
    },
})

-- Custom Topbar Buttons
Window:CreateTopbarButton("Discord", "message-square", function() setclipboard("https://discord.gg/pbUCMc8VFs") print("Discord link copied!") end, 990)
Window:CreateTopbarButton("Toggle UI", "monitor", function() Window:ToggleTransparency(not WindUI:GetTransparency()) end, 988)


-- Custom Open Button
Window:EditOpenButton({
    Title = "VicoX",
    Icon = "swords",
    CornerRadius = UDim.new(0, 16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("#FF0000"), Color3.fromHex("#FFFF00")),
    Draggable = true,
})

-- Create Tabs
local Tabs = {
    Home = Window:Tab({ Title = "Home", Icon = "wind", Desc = "Homies Dayum" }),
    Special = Window:Tab({ Title = "Special", Icon = "clipboard", Desc = "A special Function For you!" }), 
    Blatant = Window:Tab({ Title = "Blatant", Icon = "swords", Desc = "Gain in Blade Ball!" }),
    Visuals = Window:Tab({ Title = "Visuals", Icon = "eye", Desc = "Enhance your Blade Ball visuals." }),
    Worlds = Window:Tab({ Title = "Worlds", Icon = "cloud", Desc = "World Change your mode Visuals." }),    
    Misc = Window:Tab({ Title = "Misc", Icon = "settings", Desc = "Additional Blade Ball utilities." }),
    Players = Window:Tab({ Title = "Players", Icon = "sparkles", Desc = "Player Change set." }),
    Farm = Window:Tab({ Title = "AI", Icon = "bot", Desc = "Automate gameplay with AI." }),
    Settings = Window:Tab({ Title = "Settings", Icon = "leaf", Desc = "Settings." }),
    Config = Window:Tab({ Title = "Config", Icon = "file-cog", Desc = "Save and load your Blade Ball settings." }),
    Theme = Window:Tab({ Title = "Theme", Icon = "palette", Desc = "Customize your UI." }),
    divider1 = Window:Divider(),
    Info = Window:Tab({ Title = "Discord Info", Icon = "info", Desc = "Real-time Blade Ball server info." })
}

Window:SelectTab(1)

-- Utility Functions
function create_animation(object: Instance, info: TweenInfo, value: table)
    local animation = TweenService:Create(object, info, value)
    animation:Play()
    task.wait(info.Time)
    Debris:AddItem(animation, 0)
end

local ConnectionsManager = {}

function ConnectionsManager:disconnect()
    if not ConnectionsManager[self] then
        return
    end
    ConnectionsManager[self]:Disconnect()
    ConnectionsManager[self] = nil
end

function ConnectionsManager:abadone()
    for _, connection in ConnectionsManager do
        if typeof(connection) == 'function' then
            continue
        end
        connection:Disconnect()
        connection = nil
    end
end

ConnectionsManager['controller'] = RunService.Heartbeat:Connect(function()
    if not Window then
        ConnectionsManager:abadone()
    end
end)

local function linear_predict(a: any, b: any, time_volume: number)
    return a + (b - a) * time_volume
end

function World:get_pointer()
    local UserInputService = game:GetService("UserInputService")    
    local mouse_location = UserInputService:GetMouseLocation()
    local ray = workspace.CurrentCamera:ScreenPointToRay(mouse_location.X, mouse_location.Y, 0)    
    local target = ray.Origin + ray.Direction
    return CFrame.lookAt(ray.Origin, target)
end

function AutoParry.Lobby_Balls()
    for _, Instance in pairs(workspace.TrainingBalls:GetChildren()) do
        if Instance:GetAttribute("realBall") then
            return Instance
        end
    end
end


function AutoParry.get_ball()    
    local balls = {}
        
    for _, ball in ipairs(balls) do
        if ball:GetAttribute("realBall") then
            if ball:IsA("BasePart") then
                ball.CanCollide = false
            end
            return ball
        end
    end
       
    for _, ball in workspace.Balls:GetChildren() do
        if ball:GetAttribute("realBall") then
            if ball:IsA("BasePart") then
                ball.CanCollide = false
            end
            return ball
        end
    end   
   
    for _, instance in workspace.TrainingBalls:GetChildren() do
        if instance:GetAttribute("realBall") then
            if instance:IsA("BasePart") then
                instance.CanCollide = false
            end
            return instance
        end
    end
        
    return nil
end

function AutoParry.get_client_ball()
    for _, ball in workspace.Balls:GetChildren() do
        if not ball:GetAttribute("realBall") then
            return ball
        end
    end
end

function Player:get_aim_entity()
    local closest_entity = nil
    local minimal_dot_product = -math.huge
    local camera_direction = workspace.CurrentCamera.CFrame.LookVector
    for _, player in workspace.Alive:GetChildren() do
        if not player or player.Name == LocalPlayer.Name or not player:FindFirstChild('HumanoidRootPart') then
            continue
        end
        local entity_direction = (player.HumanoidRootPart.Position - workspace.CurrentCamera.CFrame.Position).Unit
        local dot_product = camera_direction:Dot(entity_direction)
        if dot_product > minimal_dot_product then
            minimal_dot_product = dot_product
            closest_entity = player
        end
    end
    return closest_entity
end

function Player:get_closest_player_to_cursor()
    local closest_player = nil
    local minimal_dot_product = -math.huge
    for _, player in workspace.Alive:GetChildren() do
        if player == LocalPlayer.Character or player.Parent ~= workspace.Alive then
            continue
        end
        local player_direction = (player.PrimaryPart.Position - workspace.CurrentCamera.CFrame.Position).Unit
        local pointer = World.get_pointer()
        local dot_product = pointer.LookVector:Dot(player_direction)
        if dot_product > minimal_dot_product then
            minimal_dot_product = dot_product
            closest_player = player
        end
    end
    return closest_player
end

local Sound_Effect = true
local sound_effect_type = "DC_15X"
local CustomId = ""
local sound_assets = {
    DC_15X = 'rbxassetid://936447863',
    Neverlose = 'rbxassetid://8679627751',
    Minecraft = 'rbxassetid://8766809464',
    MinecraftHit2 = 'rbxassetid://8458185621',
    TeamfortressBonk = 'rbxassetid://8255306220',
    TeamfortressBell = 'rbxassetid://2868331684',
    Medal = "rbxassetid://6607336718",
    Fatality = "rbxassetid://6607113255",
        Skeet = "rbxassetid://6607204501",
        Switches = "rbxassetid://6607173363",
        ["Rust Headshot"] = "rbxassetid://138750331387064",
        ["Neverlose Sound"] = "rbxassetid://110168723447153",
        Bubble = "rbxassetid://6534947588",
        Laser = "rbxassetid://7837461331",
        Steve = "rbxassetid://4965083997",
        ["Call of Duty"] = "rbxassetid://5952120301",
        Bat = "rbxassetid://3333907347",
        ["TF2 Critical"] = "rbxassetid://296102734",
        Saber = "rbxassetid://8415678813",
        Bameware = "rbxassetid://3124331820",
    Custom = 'empty'
}

local function play_parry_sound()
    if not Config.sound_effect_enabled then
        return
    end
    local sound_id = sound_assets[sound_effect_type]
    if sound_effect_type == "Custom" then
        sound_id = CustomId ~= "" and "rbxassetid://" .. CustomId or "empty"
    end
    if sound_id == "empty" then
        return
    end
    local sound = Instance.new("Sound")
    sound.SoundId = sound_id
    sound.Volume = 1
    sound.Parent = workspace
    sound:Play()
    Debris:AddItem(sound, 3)
end

function AutoParry.perform_grab_animation()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild('GrabParry')
    local currently_equipped = Player.Entity.properties.sword or Player.Character:GetAttribute('CurrentlyEquippedSword')

    
    if not currently_equipped or not animation then
        warn("Failed to perform grab animation: Invalid sword or animation not found")
        return
    end
    
    local success, sword_data = pcall(function()
        return ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(currently_equipped)
    end)
    if not success or not sword_data or not sword_data['AnimationType'] then
        warn("Failed to retrieve sword data for " .. tostring(currently_equipped))
        return
    end
   
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild('Humanoid') then
        warn("Character or Humanoid not found for animation")
        return
    end
    
    for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
        if object.Name == sword_data['AnimationType'] then
            local sword_animation_type = object:FindFirstChild('GrabParry') and 'GrabParry' or object:FindFirstChild('Grab') and 'Grab'
            if sword_animation_type then
                animation = object[sword_animation_type]
            end
        end
    end
    
    local success, result = pcall(function()
        local grab_animation = character.Humanoid:LoadAnimation(animation)
        Player.properties.grab_animation = grab_animation
        grab_animation:Play()
    end)
    if not success then
        warn("Failed to load or play animation: " .. tostring(result))
    end
end

local TargetSelectionMethod = "ClosestToCursor"

function AutoParry:ParryData()
    local Camera = workspace.CurrentCamera
    if not Camera then return {0, CFrame.new(), {}, {0, 0}} end

    local ViewportSize = Camera.ViewportSize
    local LastInput = UserInputService:GetLastInputType()
    local MouseLocation = (LastInput == Enum.UserInputType.MouseButton1 or LastInput == Enum.UserInputType.MouseButton2 or LastInput == Enum.UserInputType.Keyboard)
        and UserInputService:GetMouseLocation()
        or Vector2.new(ViewportSize.X / 2, ViewportSize.Y / 2)
    local Used = {MouseLocation.X, MouseLocation.Y}
    if TargetSelectionMethod == "ClosestToCursor" then
        local ClosestEntity = Player:get_closest_player_to_cursor()
        if closest_player and closest_player.PrimaryPart then
            Used = Camera:WorldToScreenPoint(closest_entity.PrimaryPart.Position)
        end
    end

    local Alive = workspace.Alive:GetChildren()
    local Events = table.create(#Alive)
    for _, v in ipairs(Alive) do
        Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
    end
    
    local directionMap = {
        ["Linear"] = function()
            local target_pos = AutoParry.entity_properties.server_position or Vector3.zero
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_pos + Vector3.new(math.random(-100, 100), math.random(-50, 50), math.random(-100, 100)))
        end,
        ["Backwards"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.LookVector * 100000) + Vector3.new(math.random(-100, 100), math.random(1000, 2000), math.random(-100, 100)))
        end,
        ["Random"] = function()
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Vector3.new(math.random(-10000, 10000), math.random(-5000, 5000), math.random(-10000, 10000)))
        end,
        ["Accelerated"] = function()
            local target_pos = AutoParry.entity_properties.server_position or Vector3.zero
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_pos + Vector3.new(math.random(-50, 50), math.random(200, 400), math.random(-50, 50)))
        end,
        ["Right"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.RightVector * 100000) + Vector3.new(math.random(1000, 2000), math.random(-100, 100), math.random(-100, 100)))
        end,
        ["Left"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.RightVector * 100000) + Vector3.new(math.random(-2000, -1000), math.random(-100, 100), math.random(-100, 100)))
        end,
        ["LeftSharp"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.RightVector * 150000) + Vector3.new(math.random(-3000, -1500), math.random(-50, 50), math.random(-50, 50)))
        end,
        ["LeftSemiSharp"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.RightVector * 80000) + Vector3.new(math.random(-1500, -500), math.random(-50, 50), math.random(-50, 50)))
        end,
        ["Up"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.UpVector * 100000) + Vector3.new(math.random(-100, 100), math.random(1000, 2000), math.random(-100, 100)))
        end,
        ["Down"] = function()
            return CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.UpVector * 100000) + Vector3.new(math.random(-100, 100), math.random(-2000, -1000), math.random(-100, 100)))
        end,
        ["Normal"] = function()
            return Camera.CFrame
        end,
        ["FollowCamera"] = function()
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Camera.CFrame.Position + Camera.CFrame.LookVector * 100000 + Vector3.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)))
        end,
        ["Forward"] = function()
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, LocalPlayer.Character.PrimaryPart.Position + LocalPlayer.Character.PrimaryPart.CFrame.LookVector * 100000 + Vector3.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)))
        end,
        ["Circular"] = function()
            local angle = math.rad(math.random(0, 360))
            local offset = Vector3.new(math.cos(angle) * 10000, math.sin(angle) * 5000, math.random(-5000, 5000))
            local target_pos = AutoParry.entity_properties.server_position or Vector3.zero
            return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_pos + offset)
        end,
        ["Default"] = function()
            return Camera.CFrame * CFrame.new(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
        end
    }

    return {0, directionMap[Config.curve_method] and directionMap[Config.curve_method]() or Camera.CFrame, Events, Used}
end

function AutoParry:ExecuteParry()    
    task.spawn(function()
        local VicoX = AutoParry:ParryData()    
        local Hash = (Parry_Arg and string.match(Parry_Arg, "PARRY_HASH_FAKE")) and nil or Parry_Arg    
        Parry_Remote:FireServer(Hash, Parry_Key, table.unpack(VicoX))          
    end)
end

function AutoParry:PerformParry()    
    local ball_properties = AutoParry.ball.properties
    if ball_properties.cooldown and not ball_properties.auto_spam then
        return
    end

    ball_properties.parries += 1
    ball_properties.last_hit = tick()

    local camera = workspace.CurrentCamera
    if not camera then
        return
    end
    local camera_position = camera.CFrame.Position
    local target_position = AutoParry.entity_properties.server_position or Vector3.zero
    local direction = camera.CFrame

    if not ball_properties.auto_spam then 
        pcall(function()
            AutoParry:perform_grab_animation()
        end)
        ball_properties.cooldown = true

        local current_curve = Config.curve_method
        if current_curve == "Linear" then
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_position + Vector3.new(math.random(-100, 100), math.random(-50, 50), math.random(-100, 100)))
        elseif current_curve == "Backwards" then
            direction = CFrame.new(camera_position, camera_position + (-camera.CFrame.LookVector * 100000) + Vector3.new(math.random(-100, 100), math.random(1000, 2000), math.random(-100, 100)))
        elseif current_curve == "Random" then
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Vector3.new(math.random(-10000, 10000), math.random(-5000, 5000), math.random(-10000, 10000)))
        elseif current_curve == "Accelerated" then
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_position + Vector3.new(math.random(-50, 50), math.random(200, 400), math.random(-50, 50)))
        elseif current_curve == "Right" then
            direction = CFrame.new(camera_position, camera_position + (camera.CFrame.RightVector * 100000) + Vector3.new(math.random(1000, 2000), math.random(-100, 100), math.random(-100, 100)))
        elseif current_curve == "Left" then
            direction = CFrame.new(camera_position, camera_position + (-camera.CFrame.RightVector * 100000) + Vector3.new(math.random(-2000, -1000), math.random(-100, 100), math.random(-100, 100)))
        elseif current_curve == "LeftSharp" then
            direction = CFrame.new(camera_position, camera_position + (-camera.CFrame.RightVector * 150000) + Vector3.new(math.random(-3000, -1500), math.random(-50, 50), math.random(-50, 50)))
        elseif current_curve == "LeftSemiSharp" then
            direction = CFrame.new(camera_position, camera_position + (-camera.CFrame.RightVector * 80000) + Vector3.new(math.random(-1500, -500), math.random(-50, 50), math.random(-50, 50)))
        elseif current_curve == "Up" then
            direction = CFrame.new(camera_position, camera_position + (camera.CFrame.UpVector * 100000) + Vector3.new(math.random(-100, 100), math.random(1000, 2000), math.random(-100, 100)))
        elseif current_curve == "Down" then
            direction = CFrame.new(camera_position, camera_position + (-camera.CFrame.UpVector * 100000) + Vector3.new(math.random(-100, 100), math.random(-2000, -1000), math.random(-100, 100)))
        elseif current_curve == "Normal" then
            direction = camera.CFrame
        elseif current_curve == "FollowCamera" then
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, camera_position + camera.CFrame.LookVector * 100000 + Vector3.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)))
        elseif current_curve == "Forward" then
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, LocalPlayer.Character.PrimaryPart.Position + LocalPlayer.Character.PrimaryPart.CFrame.LookVector * 100000 + Vector3.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)))
        elseif current_curve == "Circular" then
            local angle = math.rad(math.random(0, 360))
            local offset = Vector3.new(math.cos(angle) * 10000, math.sin(angle) * 5000, math.random(-5000, 5000))
            direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, target_position + offset)
        end
    else
        direction = CFrame.new(camera_position, target_position + Vector3.new(0, 300, 0))
    end

    local parry_data = AutoParry:ParryData()
    local target_name = AutoParry.target.aim and AutoParry.target.aim.Name or ""
    local target_data = target_name ~= "" and { [target_name] = target_position } or {}
    
    if SelectedParryMethod == "getgc" then            
        pcall(function()
            VicoX(           
                0,
                direction, 
                target_data,
                { target_position.X, target_position.Y }            
            )
        end)
    elseif SelectedParryMethod == "Hook" then        
        pcall(function()
            if not FirstParryDone then
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)
                task.wait(0.015)
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0.001)
                FirstParryDone = true
            else                           
                for remote, originalArgs in pairs(revertedRemotes) do
                    local modifiedArgs = {
                        originalArgs[1],
                        originalArgs[2],
                        originalArgs[3],
                        parry_data[2], 
                        parry_data[3],
                        parry_data[4],
                        originalArgs[7]
                    }
                    if remote:IsA("RemoteEvent") then
                        remote:FireServer(unpack(modifiedArgs))
                    elseif remote:IsA("RemoteFunction") then
                        remote:InvokeServer(unpack(modifiedArgs))
                    end
                end
            end
        end)
        if not next(revertedRemotes) then
            WindUI:Notify({
                Title = "Hook Warning",
                Content = "No parry remote captured. Try parrying manually.",
                Duration = 5,
            })
        end
    end 
        
    task.delay(0.55, function()
        if ball_properties.parries > 0 then
            ball_properties.parries -= 1
        end
        ball_properties.firstParryFired = false
    end)
end

function AutoParry.reset()
    AutoParry.ball.properties.is_curved = false
    AutoParry.ball.properties.auto_spam = false
    AutoParry.ball.properties.cooldown = false
    AutoParry.ball.properties.maximum_speed = 0
    AutoParry.ball.properties.parries = 0
    AutoParry.entity_properties.server_position = Vector3.zero
    AutoParry.target.current = nil
    AutoParry.target.from = nil
end

local deathshit = false
ReplicatedStorage.Remotes.DeathBall.OnClientEvent:Connect(function(c, d)
    deathshit = d and true or false
end)

local Infinity = false
ReplicatedStorage.Remotes.InfinityBall.OnClientEvent:Connect(function(a, b)
    Infinity = b and true or false
end)

local timehole = false
ReplicatedStorage.Remotes.TimeHoleHoldBall.OnClientEvent:Connect(function(e, f)
    timehole = f and true or false
end)

ReplicatedStorage.Remotes.PlrHellHooked.OnClientEvent:Connect(function(hooker: Model)
    AutoParry.ball.properties.hell_hook_completed = hooker.Name == LocalPlayer.Name
end)

ReplicatedStorage.Remotes.PlrHellHookCompleted.OnClientEvent:Connect(function()
    AutoParry.ball.properties.hell_hook_completed = true
end)

function AutoParry.is_curved()
	local target = AutoParry.target.current

	if not target then
		return false
	end

	local ball_properties = AutoParry.ball.properties
	local current_target = AutoParry.target.current.Name

	if target.PrimaryPart:FindFirstChild('MaxShield') and current_target ~= LocalPlayer.Name and ball_properties.distance < 50 then
		return false
	end

	if AutoParry.ball.ball_entity:FindFirstChild('TimeHole1') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
		ball_properties.auto_spam = false
		return false
	end

	if AutoParry.ball.ball_entity:FindFirstChild('WEMAZOOKIEGO') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
		return false
	end

	if AutoParry.ball.ball_entity:FindFirstChild('At2') and ball_properties.speed <= 0 then
		return true
	end

	if AutoParry.ball.ball_entity:FindFirstChild('AeroDynamicSlashVFX') then
		Debris:AddItem(AutoParry.ball.ball_entity.AeroDynamicSlashVFX, 0)
		ball_properties.auto_spam = false
		ball_properties.aero_dynamic_time = tick()
	end

	if RunTime:FindFirstChild('Tornado') then
		if ball_properties.distance > 5 and (tick() - ball_properties.aero_dynamic_time) < (RunTime.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159 then
			return true
		end
	end

	if not ball_properties.hell_hook_completed and target.Name == LocalPlayer.Name and ball_properties.distance > 5 - math.random() then
		return true
	end
	
	local ball_direction = ball_properties.velocity.Unit
	local ball_speed = ball_properties.speed
	
	-- Mengurangi speed_threshold untuk sensitivitas lebih tinggi
	local speed_threshold = math.min(ball_speed / 150, 30) -- Dari /100 ke /150
	-- Mengurangi angle_threshold untuk deteksi sudut lebih peka
	local angle_threshold = 30 * math.max(ball_properties.dot, 0) -- Dari 40 ke 30

	local player_ping = Player.Entity.properties.ping

	local accurate_direction = ball_properties.velocity.Unit
	accurate_direction *= ball_direction

	local direction_difference = (accurate_direction - ball_properties.velocity).Unit
	local accurate_dot = ball_properties.direction:Dot(direction_difference)
	local dot_difference = ball_properties.dot - accurate_dot
	-- Mengurangi dot_threshold untuk mempermudah deteksi kurva
	local dot_threshold = 0.4 - player_ping / 1500 -- Dari 0.5 - player_ping/1000 ke 0.4 - player_ping/1500

	local reach_time = ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000)
	local enough_speed = ball_properties.maximum_speed > 100

	-- Mengurangi ball_distance_threshold untuk deteksi lebih agresif
	local ball_distance_threshold = 12 - math.min(ball_properties.distance / 1000, 12) + angle_threshold + speed_threshold -- Dari 15 ke 12
	
	if enough_speed and reach_time > player_ping / 10 then
        ball_distance_threshold = math.max(ball_distance_threshold - 12, 12) -- Dari -15 ke -12
    end
	
	if ball_properties.distance < ball_distance_threshold then
		return false
	end

	if dot_difference < dot_threshold then
		return true
	end

	-- Mengurangi lerp_radians untuk deteksi perubahan kecil
	if ball_properties.lerp_radians < 0.015 then 
		ball_properties.last_curve_position = ball_properties.position
		ball_properties.last_warping = tick() 
	end

	-- Mengurangi waktu last_warping untuk respons lebih cepat
	if (tick() - ball_properties.last_warping) < (reach_time / 2) then
		return true
	end

	return ball_properties.dot < dot_threshold
end

function AutoParry.is_curveds()    
    local ball = AutoParry.ball and AutoParry.ball.ball_entity
    local ball_properties = AutoParry.ball and AutoParry.ball.properties
    local target = AutoParry.target and AutoParry.target.current
    if not ball or not ball_properties or not target or not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
        return false
    end

    local zoom = ball:FindFirstChild("zoomies")
    if not zoom then
        return false
    end

    local ping = (Player.Entity and Player.Entity.properties and Player.Entity.properties.ping or 100) / 1000

    if target:FindFirstChild("MaxShield") and target.Name ~= LocalPlayer.Name and (ball_properties.distance or math.huge) < 50 then
        return false
    end
    if ball:FindFirstChild("TimeHole1") and target.Name ~= LocalPlayer.Name and (ball_properties.distance or math.huge) < 100 then
        return false
    end
    if ball:FindFirstChild("WEMAZOOKIEGO") and target.Name ~= LocalPlayer.Name and (ball_properties.distance or math.huge) < 100 then
        return false
    end

    if ball:FindFirstChild("At2") and zoom.VectorVelocity.Magnitude <= 0 then
        return true
    end

    local tornadoTime = ball_properties.aero_dynamic_time or tick()
    if ball:FindFirstChild("AeroDynamicSlashVFX") then
        Debris:AddItem(ball.AeroDynamicSlashVFX, 0)
        tornadoTime = tick()
        ball_properties.aero_dynamic_time = tornadoTime
        ball_properties.aero_dynamic_active = true
    end

    local runtime = Workspace.Runtime
    if runtime:FindFirstChild("Tornado") then
        if (tick() - tornadoTime) < ((runtime.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159) then
            return true
        end
    end

    if deathshit then
        ball_properties.auto_spam = false
        return true
    end
    if Infinity then
        ball_properties.auto_spam = false
        return true
    end
    if timehole then
        return true
    end

    if not (ball_properties.hell_hook_completed or false) and target.Name == LocalPlayer.Name and ( ball_properties.distance or math.huge) > 5 then
        return true
    end

    local currentVel = zoom.VectorVelocity
    ball_properties.recent_velocities = ball_properties.recent_velocities or {}
    table.insert(ball_properties.recent_velocities, currentVel)
    if #ball_properties.recent_velocities > 10 then
        table.remove(ball_properties.recent_velocities, 1)
    end

    local totalWeight = 0
    local weightedSum = Vector3.new(0, 0, 0)
    for i, vel in ipairs(ball_properties.recent_velocities) do
        local weight = i / #ball_properties.recent_velocities
        weightedSum = weightedSum + vel * weight
        totalWeight = totalWeight + weight
    end
    local avgVel = totalWeight > 0 and weightedSum / totalWeight or (ball_properties.velocity or currentVel)

    local ballDir = avgVel.Magnitude > 0 and avgVel.Unit or (ball_properties.velocity and ball_properties.velocity.Unit or Vector3.new(0, 0, 1))
    local toBall = (LocalPlayer.Character.PrimaryPart.Position - ball.Position).Unit
    local dotVal = toBall:Dot(ballDir)

    -- Meningkatkan batas dotVal untuk deteksi lebih mudah
    if dotVal >= 0.98 then -- Dari 0.97 ke 0.98
        return false
    end

    local speed = avgVel.Magnitude
    local distance = ball_properties.distance or (LocalPlayer.Character.PrimaryPart.Position - ball.Position).Magnitude
    local reachTime = distance / math.max(speed, 1) - ping

    -- Mengurangi speedThreshold dan angleThreshold
    local speedThreshold = linear_predict(5, 25, math.min(speed / 1000, 1)) -- Dari 7,30 ke 5,25
    local angleThreshold = 25 * math.max(dotVal, 0) -- Dari 30 ke 25
    -- Mengurangi dotThreshold
    local dotThreshold = linear_predict(0.15, 0.35, math.min(ping, 1)) - ping 
    local ballDistanceThreshold = 8 - math.min(distance / 1000, 8) + speedThreshold + angleThreshold

    if speed > 100 and reachTime > ping * 6 then
        if speed < 300 then
            ballDistanceThreshold = math.max(ballDistanceThreshold - 8, 8) -- Dari -10 ke -8
        elseif speed < 600 then
            ballDistanceThreshold = math.max(ballDistanceThreshold - 9, 9) -- Dari -11 ke -9
        elseif speed < 1000 then
            ballDistanceThreshold = math.max(ballDistanceThreshold - 10, 10) -- Dari -12 ke -10
        elseif speed < 1500 then
            ballDistanceThreshold = math.max(ballDistanceThreshold - 11, 11) -- Dari -13 ke -11
        else
            ballDistanceThreshold = math.max(ballDistanceThreshold - 12, 12) -- Dari -14 ke -12
        end
    end

    if distance < ballDistanceThreshold then
        return false
    end

    local backwardsCurveDetected = false
    local backwardsAngleThreshold = math.max(70, math.min(80, 70 + (speed / 200))) 
    local playerPos = LocalPlayer.Character.PrimaryPart.Position
    local ballPos = ball.Position
    local horizDirection = Vector3.new(playerPos.X - ballPos.X, 0, playerPos.Z - ballPos.Z)
    if horizDirection.Magnitude > 0 then
        horizDirection = horizDirection.Unit
        local awayFromPlayer = -horizDirection
        local horizBallDir = Vector3.new(ballDir.X, 0, ballDir.Z)
        if horizBallDir.Magnitude > 0 then
            horizBallDir = horizBallDir.Unit
            local backwardsAngle = math.deg(math.acos(math.clamp(awayFromPlayer:Dot(horizBallDir), -1, 1)))
            if backwardsAngle < backwardsAngleThreshold then
                backwardsCurveDetected = true
            end
        end
    end

    ball_properties.previous_velocities = ball_properties.previous_velocities or {}
    local similarity = 0
    if #ball_properties.previous_velocities > 0 then
        local prevVel = ball_properties.previous_velocities[#ball_properties.previous_velocities]
        local velDiff = (currentVel - prevVel).Magnitude
        similarity = 1 - math.min(velDiff / math.max(prevVel.Magnitude, 0.1), 1)
    end
    table.insert(ball_properties.previous_velocities, currentVel)
    if #ball_properties.previous_velocities > 5 then
        table.remove(ball_properties.previous_velocities, 1)
    end


    if similarity < 0.6 and (tick() - (ball_properties.last_warping or 0)) > 0.08 then
        ball_properties.last_warping = tick()
        return true
    end

    if dotVal < dotThreshold or backwardsCurveDetected then
        return true
    end

    return false
end

local old_from_target = nil :: Model

function AutoParry:is_spam() 
	local target = AutoParry.target.current
    local ball_properties = AutoParry.ball.properties
    local player_character = LocalPlayer.Character
    local current_changed = AutoParry.target.current_changed
    local direction_changed_on_cframe = AutoParry.target.direction_changed_on_cframe
    
    if current_changed and direction_changed_on_cframe then
       self.parries = 0
       return false
    end
    
    if player_character and player_character.PrimaryPart and target and target.PrimaryPart and workspace.CurrentCamera then
        local camera_cframe = workspace.CurrentCamera.CFrame
        local camera_direction = camera_cframe.LookVector
        local current_target_position = target.PrimaryPart.Position
        local vector_to_current_target = (current_target_position - camera_cframe.Position).Unit
        local dot_to_current_target = camera_direction:Dot(vector_to_current_target)

        
        for _, other_player in pairs(workspace.Alive:GetChildren()) do
            if other_player ~= target and other_player ~= player_character and other_player:IsA("Model") and other_player.PrimaryPart then
                local other_position = other_player.PrimaryPart.Position
                local vector_to_other = (other_position - camera_cframe.Position).Unit
                local dot_to_other = camera_direction:Dot(vector_to_other)
                
                if dot_to_other > dot_to_current_target + 0.1 then
                    return false
                end
            end
        end
    end

    local Character = LocalPlayer.Character

    if Character.Parent == workspace.Dead then               
        return
    end

    if not target or not target.Parent or not player_character or not player_character.Parent then
        self.parries = 0
        return false
    end

    if not AutoParry.ball or not ball_properties or not ball_properties.position then
        self.parries = 0
        return false
    end

    local target_humanoid = target:FindFirstChildOfClass("Humanoid")
    if not target_humanoid or target_humanoid.Health <= 0 then      
        return false
    end

    local old_from_target = AutoParry.target.from
    if AutoParry.target.from ~= player_character then
        old_from_target = AutoParry.target.from
    end

    if self.parries < 3 and AutoParry.target.from == old_from_target then
        return false
    end

	local player_ping = Player.Entity.properties.ping
	local distance_threshold = 19 + (player_ping / 80)

	local ball_properties = AutoParry.ball.properties
	local reach_time = ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000)

	if (tick() - self.last_hit) > 0.8 and self.entity_distance > distance_threshold and self.parries < 3 then
		self.parries = 1

		return false
	end

 	if ball_properties.lerp_radians then       
        local curve_threshold = 0.028 + (player_ping / 100) 
        if ball_properties.lerp_radians > curve_threshold then
            if self.parries > 5 then
                self.parries = 2
            end
            return false
        end
    end

    local is_curve = false
    local is_high_curve = false
    if ball_properties.lerp_radians then       
        local curve_threshold = 0.028 + (player_ping / 100)
        local dot_threshold = 0.2 - player_ping
        local high_curve_dot_threshold = 0.4
        if ball_properties.lerp_radians > curve_threshold then
            is_curve = true
            if ball_properties.dot < high_curve_dot_threshold or (tick() - ball_properties.last_warping) < (reach_time / (1.1 / time_threshold_adjust)) then
                is_high_curve = true
                return false
            elseif ball_properties.dot < dot_threshold then
                if self.parries < 7 then
                    return false
                end
                if self.parries >= 7 then
                    self.parries = 1
                end
            end
        end
    end

	if (tick() - ball_properties.last_warping) < (reach_time / 1.3) and self.entity_distance > distance_threshold and self.parries < 4 then
		if self.parries > 3 then
			self.parries = 1
		end

		return false
	end

	if math.abs(self.speed - self.old_speed) < 5.2 and self.entity_distance > distance_threshold and self.speed < 60 and self.parries < 3 then
		if self.parries > 3 then
			self.parries = 0
		end

		return false
	end
	
	if self.speed < 50 then
		self.parries = 1

		return false
	end

	if self.maximum_speed < self.speed and self.entity_distance > distance_threshold then
		self.parries = 1
		
		return false
	end

	if self.entity_distance > self.range and self.entity_distance > distance_threshold then
		if self.parries > 2 then
			self.parries = 1
		end

		return false
	end

	if self.ball_distance > self.range and self.entity_distance > distance_threshold then
		if self.parries > 2 then
			self.parries = 2
		end

		return false
	end

	if self.last_position_distance > self.spam_accuracy and self.entity_distance > distance_threshold then
		if self.parries > 4 then
			self.parries = 2
		end

		return false
	end

	if self.ball_distance > self.spam_accuracy and self.ball_distance > distance_threshold then
		if self.parries > 3 then
			self.parries = 2
		end

		return false
	end

	if self.entity_distance > self.spam_accuracy and self.entity_distance > (distance_threshold - math.pi) then
		if self.parries > 3 then
			self.parries = 2
		end

		return false
	end

    return true	
end


AutoParry.ball.training_ball_entity = AutoParry.Lobby_Balls()
AutoParry.ball.ball_entity = AutoParry.get_ball()
AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()


NetworkClient:SetOutgoingKBPSLimit(math.huge)

local cached_ping = 0
local last_ping_update = 0
local function update_cached_ping()
    if tick() - last_ping_update >= 0.01 then
        cached_ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
        last_ping_update = tick()
    end
    return cached_ping
end

local function setupConnections()    
    task.spawn(function()
        if ConnectionsManager['server_position_simulation'] then
            ConnectionsManager:disconnect('server_position_simulation')
        end
        if ConnectionsManager['player_properties_update'] then
            ConnectionsManager:disconnect('player_properties_update')
        end
        if ConnectionsManager['ball_properties_update'] then
            ConnectionsManager:disconnect('ball_properties_update')
        end

        ConnectionsManager['server_position_simulation'] = RunService.Heartbeat:Connect(function()
            local ping = update_cached_ping()
            if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
                return
            end
            local primary_part = LocalPlayer.Character.PrimaryPart
            local old_position = primary_part.Position   
            Player.Entity.properties.server_position = old_position
        end)

        ConnectionsManager['player_properties_update'] = RunService.PostSimulation:Connect(function()
            local character = LocalPlayer.Character
            if not character or not character.PrimaryPart then
                return
            end
            local player_properties = Player.Entity.properties
            player_properties.sword = character:GetAttribute('CurrentlyEquippedSword')
            player_properties.ping = update_cached_ping()
            player_properties.velocity = character.PrimaryPart.AssemblyLinearVelocity
            player_properties.speed = player_properties.velocity.Magnitude
            player_properties.is_moving = player_properties.speed > 16

            player_properties.is_moving_backwards = false
            if AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.position then
                local ball_position = AutoParry.ball.properties.position
                local character_position = character.PrimaryPart.Position
                local direction_to_ball = (ball_position - character_position).Unit
                local velocity_direction = player_properties.velocity.Unit        
                if player_properties.speed > 16 and direction_to_ball:Dot(velocity_direction) < -0.1 then
                    player_properties.is_moving_backwards = true
                end
            end
        end)

        ConnectionsManager['ball_properties_update'] = RunService.PostSimulation:Connect(function()
            local balls = {}
            local ball = AutoParry.ball.ball_entity
            local lobby_ball = AutoParry.ball.training_ball_entity
            if ball then table.insert(balls, ball) end
            if lobby_ball then table.insert(balls, lobby_ball) end

            if not balls or #balls == 0 then
                return
            end

            for _, ball in pairs(balls) do
                local zoomies = ball:FindFirstChild('zoomies')
                local ball_properties = AutoParry.ball.properties

                ball_properties.position = ball.Position
                ball_properties.velocity = ball.AssemblyLinearVelocity

                if zoomies then
                    ball_properties.velocity = zoomies.VectorVelocity
                end

                ball_properties.distance = (Player.Entity.properties.server_position - ball_properties.position).Magnitude
                ball_properties.speed = ball_properties.velocity.Magnitude
                ball_properties.direction = (Player.Entity.properties.server_position - ball_properties.position).Unit
                ball_properties.dot = ball_properties.direction:Dot(ball_properties.velocity.Unit)
                ball_properties.radians = math.rad(math.asin(ball_properties.dot))
                ball_properties.lerp_radians = ball_properties.lerp_radians and (ball_properties.lerp_radians * 0.3 + ball_properties.radians * 0.9) or ball_properties.radians

                if not (ball_properties.lerp_radians < 0) and not (ball_properties.lerp_radians > 0) then
                    ball_properties.lerp_radians = 0.027
                end

                ball_properties.maximum_speed = math.max(ball_properties.speed, ball_properties.maximum_speed)
                
                AutoParry.target.aim = not UserInputService.TouchEnabled and (Player.get_closest_player_to_cursor and Player.get_closest_player_to_cursor() or nil) or (Player.get_aim_entity and Player.get_aim_entity() or nil)

                if ball:GetAttribute('from') then
                    AutoParry.target.from = workspace.Alive:FindFirstChild(ball:GetAttribute('from'))
                end

                if ball:GetAttribute('target') then
                    AutoParry.target.current = workspace.Alive:FindFirstChild(ball:GetAttribute('target'))
                end

                if not AutoParry.target.current then
                    return
                end

                ball_properties.rotation = ball_properties.position

                if AutoParry.target.current.Name == LocalPlayer.Name then
                    ball_properties.rotation = AutoParry.target.aim and AutoParry.target.aim.PrimaryPart and AutoParry.target.aim.PrimaryPart.Position or ball_properties.position
                    return
                end

                local target_server_position = AutoParry.target.current.PrimaryPart.Position
                local target_velocity = AutoParry.target.current.PrimaryPart.AssemblyLinearVelocity

                AutoParry.entity_properties.server_position = target_server_position
                AutoParry.entity_properties.velocity = target_velocity
                AutoParry.entity_properties.distance = (LocalPlayer.Character and LocalPlayer.Character.PrimaryPart and (LocalPlayer.Character.PrimaryPart.Position - target_server_position).Magnitude or math.huge)
                AutoParry.entity_properties.direction = (Player.Entity.properties.server_position - target_server_position).Unit
                AutoParry.entity_properties.speed = target_velocity.Magnitude
                AutoParry.entity_properties.is_moving = target_velocity.Magnitude > 0.1
                AutoParry.entity_properties.dot = AutoParry.entity_properties.is_moving and math.max(AutoParry.entity_properties.direction:Dot(target_velocity.Unit), 0)

                ball.AncestryChanged:Connect(function(_, parent)
                    if not parent then
                        ball_properties.maximum_speed = 0
                        AutoParry.target.current = nil
                        AutoParry.target.from = nil
                    end
                end)
            end
        end)
    end)
end

task.spawn(setupConnections)

LocalPlayer.CharacterAdded:Connect(function(character)
    if character then
        task.spawn(setupConnections)
    end
end)

if LocalPlayer.Character then
    task.spawn(setupConnections)
end



local AutoAbility = {
    enabled = false, -- Controlled by UI toggle
    parry_cooldown = false,
}

function AutoAbility:isCooldownInEffect(uigradient)
    if not uigradient then return false end
    return uigradient.Offset.Y < 0.4
end

function AutoAbility:isAbilityReady(uigradient)
    if not uigradient then return false end
    return uigradient.Offset.Y == 0.5
end

function AutoAbility:cooldownProtection()
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
    local hotbar = playerGui:WaitForChild("Hotbar")
    local parryCD = hotbar:WaitForChild("Block"):WaitForChild("UIGradient")

    if self:isCooldownInEffect(parryCD) then
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("AbilityButtonPress"):FireServer()
        self.parry_cooldown = true
        task.delay(0.5, function() -- Adjust delay based on game mechanics
            self.parry_cooldown = false
        end)
        return true
    end
    return false
end

function AutoAbility:performAutoAbility()
    if not self.enabled or self.parry_cooldown then return false end

    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("Abilities") then return false end

    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
    local hotbar = playerGui:WaitForChild("Hotbar")
    local abilityCD = hotbar:WaitForChild("Ability"):WaitForChild("UIGradient")

    if not self:isAbilityReady(abilityCD) then return false end

    
    local abilitiesToCheck = {
        "Raging Deflection ",
        "Rapture ",
        "Calming Deflection ",
        "Aerodynamic Slash ",
        "Fracture ",
        "Death Slash "
    }

    local abilityActivated = false
    for _, abilityName in ipairs(abilitiesToCheck) do
        local ability = character.Abilities:FindFirstChild(abilityName)
        if ability and ability.Enabled then
            abilityActivated = true
            break
        end
    end

    if abilityActivated then
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("AbilityButtonPress"):FireServer()
        if character.Abilities:FindFirstChild("Death Slash") and character.Abilities["Death Slash"].Enabled then
            task.wait(2.432)
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("DeathSlashShootActivation"):FireServer(true)
        end
        return true
    end

    return false
end


ConnectionsManager['auto_spam'] = RunService.Heartbeat:Connect(function()
    if not AutoParry.ball.properties.auto_spam then              
        return
    end    

    local speeddo = getgenv().speeddo
    for v = 1, speeddo do
        AutoParry:PerformParry()
    end
end)

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(slash: any, root: any)
    task.spawn(function()
        if root.Parent and root.Parent ~= LocalPlayer.Character and root.Parent.Parent == workspace.Alive then
            AutoParry.ball.properties.cooldown = false
        end
    end)
    play_parry_sound()
end)

ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
    if LocalPlayer.Character.Parent ~= Alive then
        return
    end
    
    if not Player.properties.grab_animation then
        return
    end
    
    Player.properties.grab_animation:Stop()
    
    local ball = AutoParry.get_client_ball()
    
    if not ball then
        return
    end
    
    ball = nil
end)



ConnectionsManager['auto_parry'] = RunService.PreSimulation:Connect(function()
    local auto_parry_enabled = Config.auto_parry
           
    if not auto_parry_enabled then
        AutoParry.reset()
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return
    end

    local Character = LocalPlayer.Character

    if not Character then
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return
    end

    if Character.Parent == workspace.Dead then
        AutoParry.reset()
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return
    end

    if not AutoParry.ball.ball_entity then
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return
    end

    local ball_properties = AutoParry.ball.properties
    local Singularity_Cape = LocalPlayer.Character.PrimaryPart:FindFirstChild('SingularityCape')    
    ball_properties.is_curved = AutoParry.is_curved()
    ball_properties.is_curveds = AutoParry.is_curveds()
    
    
    if AutoParry.entity_properties.distance and AutoParry.entity_properties.distance >= 5 and AutoParry.entity_properties.distance <= 7 then
        ball_properties.is_curved = false
        ball_properties.is_curveds = false
    end

    
    if Singularity_Cape then
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return 
    end

    local ping_threshold = math.clamp(Player.Entity.properties.ping / 10, 5, 18)
    local ping_thresholds = math.clamp(Player.Entity.properties.ping / 10, 2, 18)

    local player_properties = Player.Entity.properties
    
    local baseMoveAmount = 0.5
    local moveAmount = baseMoveAmount * (1 / (AutoParry.entity_properties.distance + 0.01)) * 1000

    local spam_accuracity = math.min(moveAmount + (ball_properties.maximum_speed / 8.4), (150 + moveAmount))
    local parry_accuracity = ping_threshold + ball_properties.maximum_speed / 11.2 + ping_threshold

    if player_properties.is_moving then
        parry_accuracity *= 1.1       
    end

    if player_properties.is_moving_backwards then
        parry_accuracity *= (1 / 1.05)        
    end
    
    if Player.Entity.properties.ping >= 290 then
        parry_accuracity = parry_accuracity * (1 + (Player.Entity.properties.ping / 500))
    end

    ball_properties.spam_range = (ping_thresholds + ball_properties.speed) * 1.26 / 3.14     
    ball_properties.parry_range = ping_threshold + ball_properties.speed / math.pi

    if Player.Entity.properties.sword == 'Titan Blade' then
        ball_properties.parry_range += 11
        ball_properties.spam_range += 2
    end	

    local distance_to_last_position = LocalPlayer:DistanceFromCharacter(ball_properties.last_position)
   
    if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name and AutoAbility.enabled then
        if AutoAbility:cooldownProtection() then
            AutoParry.ball.properties.auto_spam = false
            AutoParry.ball.properties.parries = 0
            return
        end
        if AutoAbility:performAutoAbility() then
            AutoParry.ball.properties.auto_spam = false
            AutoParry.ball.properties.parries = 0
            return
        end
    end
    
    AutoParry.target.current_changed = AutoParry.target.current_changed or false
    AutoParry.target.direction_changed_on_cframe = AutoParry.target.direction_changed_on_cframe or false

    if AutoParry.target.current ~= AutoParry.target.previous then
        AutoParry.target.current_changed = true
        AutoParry.target.previous = AutoParry.target.current
    else
        AutoParry.target.current_changed = false
    end

    if AutoParry.target.current then
        local current_cframe = AutoParry.target.current.PrimaryPart and AutoParry.target.current.PrimaryPart.CFrame or CFrame.new()
        if not AutoParry.target.last_cframe then
            AutoParry.target.last_cframe = current_cframe
        end
        local current_direction = current_cframe.LookVector
        local last_direction = AutoParry.target.last_cframe.LookVector
        AutoParry.target.direction_changed_on_cframe = (current_direction - last_direction).Magnitude > 0.1
        AutoParry.target.last_cframe = current_cframe
    else
        AutoParry.target.direction_changed_on_cframe = false
    end                          
    
    if ball_properties.auto_spam and AutoParry.target.current and not AutoParry.target.direction_changed_on_cframe then
        ball_properties.auto_spam = AutoParry.is_spam({
            speed = ball_properties.speed,
            spam_accuracy = spam_accuracity,
            parries = ball_properties.parries,
            ball_speed = ball_properties.speed,
            range = ball_properties.spam_range / (math.pi - ping_threshold / 10),
            last_hit = ball_properties.last_hit,
            ball_distance = ball_properties.distance,
            maximum_speed = ball_properties.maximum_speed,
            old_speed = AutoParry.ball.properties.old_speed,
            entity_distance = AutoParry.entity_properties.distance,
            last_position_distance = distance_to_last_position,
        })
    end

    if ball_properties.auto_spam then
        return
    end

    if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name then
        ball_properties.auto_spam = AutoParry.is_spam({
            speed = ball_properties.speed,
            spam_accuracy = spam_accuracity,
            parries = ball_properties.parries,
            ball_speed = ball_properties.speed,
            range = ball_properties.spam_range,
            last_hit = ball_properties.last_hit,
            ball_distance = ball_properties.distance,
            maximum_speed = ball_properties.maximum_speed,
            old_speed = AutoParry.ball.properties.old_speed,
            entity_distance = AutoParry.entity_properties.distance,
            last_position_distance = distance_to_last_position,
        })
    end

    if ball_properties.auto_spam then
        return
    end

    if ball_properties.is_curveds or ball_properties.is_curved then              
        return
    end

    if (player_properties.is_moving or player_properties.is_moving_backwards) and (ball_properties.is_curveds or ball_properties.is_curved) then       
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.parries = 0
        return
    end
    
    if ball_properties.distance > ball_properties.parry_range and ball_properties.distance > parry_accuracity then        
        return
    end
	
    if AutoParry.target.current and AutoParry.target.current ~= LocalPlayer.Character then        
        return
    end

    local lastPosition = LocalPlayer.Character.PrimaryPart.Position 
    local target_Ball_Distance = (ball_properties.position - AutoParry.entity_properties.server_position).Magnitude
       
    if parry_mode == "Legit" then
        if target_Ball_Distance <= 10 and AutoParry.entity_properties.distance <= 50 then
            if math.random(1, 2) == 1 then
                task.spawn(function() AutoParry:PerformParry() end)
            end
        end
    end
    
    if parry_mode == "Legit" then
        if ball_properties.maximum_speed >= 250 then
            parry_accuracity *= 1.2
        end
    end
    
    lastPosition = LocalPlayer.Character.PrimaryPart.Position 
    ball_properties.last_ball_pos = ball_properties.position

    if not ball_properties.auto_spam then
       task.spawn(function() AutoParry:PerformParry() end) 
    return
   end

    task.spawn(function()
        repeat
            RunService.PreSimulation:Wait(0)
        until 
            (tick() - ball_properties.last_hit) > (1 - math.clamp(ping_threshold / 100, 0.1, 0.6))

        ball_properties.cooldown = false
    end)
end)




local LocalPlayer = Players.LocalPlayer

-- Create ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AutoParryDebugGui"
ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Main frame
local DebugFrame = Instance.new("Frame")
DebugFrame.Size = UDim2.new(0, 180, 0, 280) -- Smaller for Android
DebugFrame.Position = UDim2.new(0, 5, 0, 5)
DebugFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
DebugFrame.BackgroundTransparency = 0.2
DebugFrame.BorderSizePixel = 0
DebugFrame.Parent = ScreenGui

-- Rounded corners
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 8)
UICorner.Parent = DebugFrame

-- Shadow effect
local Shadow = Instance.new("ImageLabel")
Shadow.Size = UDim2.new(1, 16, 1, 16)
Shadow.Position = UDim2.new(0, -8, 0, -8)
Shadow.BackgroundTransparency = 1
Shadow.Image = "rbxassetid://1316045217"
Shadow.ImageTransparency = 0.6
Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
Shadow.ScaleType = Enum.ScaleType.Slice
Shadow.SliceCenter = Rect.new(10, 10, 10, 10)
Shadow.ZIndex = -1
Shadow.Parent = DebugFrame

-- Make frame draggable
local dragging, dragInput, dragStart, startPos
DebugFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = DebugFrame.Position
        input:Destroy()
    end
end)

DebugFrame.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        dragInput = input
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

RunService.RenderStepped:Connect(function()
    if dragging and dragInput then
        local delta = dragInput.Position - dragStart
        DebugFrame.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
end)

-- Title bar
local TitleLabel = Instance.new("TextLabel")
TitleLabel.Size = UDim2.new(1, -35, 0, 25)
TitleLabel.Position = UDim2.new(0, 8, 0, 5)
TitleLabel.BackgroundTransparency = 1
TitleLabel.Text = "Debug"
TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleLabel.TextSize = 14
TitleLabel.Font = Enum.Font.GothamBold
TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
TitleLabel.Parent = DebugFrame

-- Minimize/maximize button for main frame
local MainToggleButton = Instance.new("TextButton")
MainToggleButton.Size = UDim2.new(0, 25, 0, 25)
MainToggleButton.Position = UDim2.new(1, -30, 0, 5)
MainToggleButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
MainToggleButton.Text = "-"
MainToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MainToggleButton.TextSize = 14
MainToggleButton.Font = Enum.Font.Gotham
MainToggleButton.Parent = DebugFrame
local MainToggleCorner = Instance.new("UICorner")
MainToggleCorner.CornerRadius = UDim.new(0, 5)
MainToggleCorner.Parent = MainToggleButton

local MainToggleStroke = Instance.new("UIStroke")
MainToggleStroke.Color = Color3.fromRGB(100, 100, 100)
MainToggleStroke.Thickness = 1
MainToggleStroke.Parent = MainToggleButton

-- Scrolling frame for debug sections
local DebugContainer = Instance.new("ScrollingFrame")
DebugContainer.Size = UDim2.new(1, -10, 1, -35)
DebugContainer.Position = UDim2.new(0, 5, 0, 30)
DebugContainer.BackgroundTransparency = 1
DebugContainer.ScrollBarThickness = 4
DebugContainer.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
DebugContainer.ClipsDescendants = true
DebugContainer.Parent = DebugFrame

-- UIListLayout for vertical stacking
local ListLayout = Instance.new("UIListLayout")
ListLayout.Padding = UDim.new(0, 4)
ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
ListLayout.Parent = DebugContainer

-- Format long values
local function formatVector3(vec)
    if typeof(vec) == "Vector3" then
        return string.format("(%.2f, %.2f, %.2f)", vec.X, vec.Y, vec.Z)
    end
    return tostring(vec)
end

-- Create debug section
local function createDebugSection(name, index)
    local SectionFrame = Instance.new("Frame")
    SectionFrame.Size = UDim2.new(1, 0, 0, 45) -- Fixed height for expanded
    SectionFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    SectionFrame.BackgroundTransparency = 0.4
    SectionFrame.BorderSizePixel = 0
    SectionFrame.LayoutOrder = index
    SectionFrame.ClipsDescendants = true -- Ensure text stays in frame
    SectionFrame.Parent = DebugContainer

    local SectionCorner = Instance.new("UICorner")
    SectionCorner.CornerRadius = UDim.new(0, 4)
    SectionCorner.Parent = SectionFrame

    local SectionStroke = Instance.new("UIStroke")
    SectionStroke.Color = Color3.fromRGB(80, 80, 80)
    SectionStroke.Thickness = 1
    SectionStroke.Parent = SectionFrame

    local ToggleButton = Instance.new("TextButton")
    ToggleButton.Size = UDim2.new(0, 18, 0, 18)
    ToggleButton.Position = UDim2.new(0, 5, 0, 5)
    ToggleButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    ToggleButton.Text = "-"
    ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    ToggleButton.TextSize = 12
    ToggleButton.Font = Enum.Font.Gotham
    ToggleButton.Parent = SectionFrame

    local ToggleButtonCorner = Instance.new("UICorner")
    ToggleButtonCorner.CornerRadius = UDim.new(0, 4)
    ToggleButtonCorner.Parent = ToggleButton

    local NameLabel = Instance.new("TextLabel")
    NameLabel.Size = UDim2.new(1, -60, 0, 18)
    NameLabel.Position = UDim2.new(0, 25, 0, 5)
    NameLabel.BackgroundTransparency = 1
    NameLabel.Text = name .. ":"
    NameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    NameLabel.TextSize = 12
    NameLabel.Font = Enum.Font.SourceSans
    NameLabel.TextXAlignment = Enum.TextXAlignment.Left
    NameLabel.TextScaled = true
    NameLabel.TextTruncate = Enum.TextTruncate.AtEnd
    NameLabel.Parent = SectionFrame

    local ValueLabel = Instance.new("TextLabel")
    ValueLabel.Size = UDim2.new(1, -10, 0, 18)
    ValueLabel.Position = UDim2.new(0, 5, 0, 23)
    ValueLabel.BackgroundTransparency = 1
    ValueLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
    ValueLabel.TextSize = 12
    ValueLabel.Font = Enum.Font.SourceSans
    ValueLabel.TextXAlignment = Enum.TextXAlignment.Left
    ValueLabel.TextScaled = true
    ValueLabel.TextTruncate = Enum.TextTruncate.AtEnd
    ValueLabel.Parent = SectionFrame

    local isCollapsed = false
    ToggleButton.MouseButton1Click:Connect(function()
        isCollapsed = not isCollapsed
        if isCollapsed then
            SectionFrame.Size = UDim2.new(1, 0, 0, 25)
            ToggleButton.Text = "+"
            ValueLabel.Visible = false
        else
            SectionFrame.Size = UDim2.new(1, 0, 0, 45)
            ToggleButton.Text = "-"
            ValueLabel.Visible = true
        end
        DebugContainer.CanvasSize = UDim2.new(0, 0, 0, ListLayout.AbsoluteContentSize.Y)
    end)

    -- Hover animation
    ToggleButton.MouseEnter:Connect(function()
        game:GetService("TweenService"):Create(ToggleButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(80, 80, 80)}):Play()
    end)
    ToggleButton.MouseLeave:Connect(function()
        game:GetService("TweenService"):Create(ToggleButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(60, 60, 60)}):Play()
    end)

    return ValueLabel
end

-- Create debug sections
local debugFields = {
    {name = "Ball Pos", value = function() return formatVector3(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.position or "N/A") end},
    {name = "Dot", value = function()
        if LocalPlayer.Character and LocalPlayer.Character.PrimaryPart and AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.position then
            local ball_position = AutoParry.ball.properties.position
            local character_position = LocalPlayer.Character.PrimaryPart.Position
            local direction_to_ball = (ball_position - character_position).Unit
            local velocity_direction = Player.Entity.properties.velocity.Unit
            return tostring(math.round(direction_to_ball:Dot(velocity_direction) * 100) / 100)
        end
        return "N/A"
    end},
    {name = "isCurved", value = function() return tostring(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.is_curved or false) end},
    {name = "isCurveds", value = function() return tostring(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.is_curveds or false) end},
    {name = "Ping", value = function() return tostring(Player.Entity.properties.ping or 0) .. " ms" end},
    {name = "AutoSpam", value = function() return tostring(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.auto_spam or false) end},
    {name = "Parry", value = function() return lastParryAttempt and "Attempted" or "None" end},
    {name = "Ball Velocity", value = function() return formatVector3(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.velocity or "N/A") end},
    {name = "Ball RotVelocity", value = function() return formatVector3(AutoParry.ball and AutoParry.ball.ball_entity and AutoParry.ball.ball_entity.RotVelocity or "N/A") end},
    {name = "Ball Rotation", value = function() return formatVector3(AutoParry.ball and AutoParry.ball.ball_entity and AutoParry.ball.ball_entity.CFrame.Position or "N/A") end},
    {name = "Ball Speed", value = function() return tostring(AutoParry.ball and AutoParry.ball.properties and AutoParry.ball.properties.speed or "N/A") end},
}

local debugLabels = {}
for i, field in ipairs(debugFields) do
    debugLabels[field.name] = createDebugSection(field.name, i)
end

-- Update CanvasSize dynamically
ListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    DebugContainer.CanvasSize = UDim2.new(0, 0, 0, ListLayout.AbsoluteContentSize.Y)
end)

-- Minimize/maximize main frame
local isMinimized = false
MainToggleButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    if isMinimized then
        DebugFrame.Size = UDim2.new(0, 180, 0, 40)
        MainToggleButton.Text = "+"
        DebugContainer.Visible = false
    else
        DebugFrame.Size = UDim2.new(0, 180, 0, 280)
        MainToggleButton.Text = "-"
        DebugContainer.Visible = true
    end
end)

-- Hover animation for main toggle
MainToggleButton.MouseEnter:Connect(function()
    game:GetService("TweenService"):Create(MainToggleButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(80, 80, 80)}):Play()
end)
MainToggleButton.MouseLeave:Connect(function()
    game:GetService("TweenService"):Create(MainToggleButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(50, 50, 50)}):Play()
end)

-- Update debug info
local lastParryAttempt = false
RunService.Heartbeat:Connect(function()
    for _, field in ipairs(debugFields) do
        debugLabels[field.name].Text = field.value()
    end
end)

-- Track parry attempts
local originalPerformParry = AutoParry.perform_parry
AutoParry.perform_parry = function(...)
    lastParryAttempt = true
    task.spawn(function()
        task.wait(0.1) -- Reset after 100ms
        lastParryAttempt = false
    end)
    return originalPerformParry(...)
end

local originalPerformParryCapital = AutoParry.PerformParry
AutoParry.PerformParry = function(...)
    lastParryAttempt = true
    task.spawn(function()
        task.wait(0.1) -- Reset after 100ms
        lastParryAttempt = false
    end)
    return originalPerformParryCapital(...)
end

local function getValidPlayers()
    local players = {}
    local myPosition = LocalPlayer.Character and (LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or LocalPlayer.Character.PrimaryPart)
    if not myPosition then return players end
    myPosition = myPosition.Position

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local primaryPart = player.Character:FindFirstChild("HumanoidRootPart") or player.Character.PrimaryPart
            if primaryPart and primaryPart.Position then
                local direction = (primaryPart.Position - myPosition).Unit
                local viewVector = (LocalPlayer.Character:GetPrimaryPartCFrame().LookVector).Unit
                if direction:Dot(viewVector) > math.cos(math.rad(60)) then
                    table.insert(players, {
                        Player = player,
                        Character = player.Character,
                        PrimaryPart = primaryPart,
                        LastPosition = primaryPart.Position,
                        Velocity = primaryPart.AssemblyLinearVelocity or Vector3.zero
                    })
                end
            end
        end
    end
    return players
end

local function getSafeBall()
    local success, ball = pcall(function()
        return AutoParry.get_ball()
    end)
    return success and ball or nil
end

local function predictPosition(currentPos, velocity, time)
    return currentPos + (velocity * time)
end

local function isStuck(currentPos)
    if (currentPos - AIStuckCheck.lastPosition).Magnitude < 1.5 then
        AIStuckCheck.stuckDuration += 1
    else
        AIStuckCheck.stuckDuration = 0
    end
    AIStuckCheck.lastPosition = currentPos
    return AIStuckCheck.stuckDuration > 8
end

local function moveToPosition(character, targetPos, aggressive)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local primaryPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
    if not humanoid or not primaryPart then return end

    local direction = (targetPos - primaryPart.Position).Unit
    local distance = (targetPos - primaryPart.Position).Magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {character}

    local raycastResult = workspace:Raycast(
        primaryPart.Position,
        direction * 8,
        raycastParams
    )

    if raycastResult and raycastResult.Instance then
        if AICooldowns.jump <= 0 and humanoid.FloorMaterial ~= Enum.Material.Air then
            humanoid.Jump = true
            AICooldowns.jump = 0.6 + math.random() * 0.3
        end
    end

    if isStuck(primaryPart.Position) then
        humanoid.Jump = true
        if AICooldowns.dash <= 0 then
            humanoid:MoveTo(primaryPart.Position + (Vector3.new(math.random(-1,1), 0, math.random(-1,1)) * 15))
            AICooldowns.dash = 2 + math.random()
        end
    end

    if aggressive then
        humanoid:MoveTo(targetPos + (direction * 2))
    else
        humanoid:MoveTo(targetPos)
    end
end

local AIMethods = {
    AdvancedPro = function(character)
        if not character then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local primaryPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        if not humanoid or not primaryPart then return end

        local ball = getSafeBall()
        local validPlayers = getValidPlayers()
        local target = nil

        if ball and (math.random() > 0.4 or #validPlayers == 0) then
            local predictionTime = 0.5 + math.random() * 0.3
            target = {
                Position = predictPosition(ball.Position, ball.AssemblyLinearVelocity or Vector3.zero, predictionTime),
                Type = "Ball"
            }
        elseif #validPlayers > 0 then
            if AICooldowns.targetSwitch <= 0 or not AITarget then
                AITarget = validPlayers[math.random(math.max(1, #validPlayers - 2), #validPlayers)]
                AICooldowns.targetSwitch = 2 + math.random() * 2
            end

            if AITarget and AITarget.PrimaryPart then
                local predictionTime = 0.4 + math.random() * 0.2
                target = {
                    Position = predictPosition(AITarget.PrimaryPart.Position, AITarget.Velocity, predictionTime),
                    Type = "Player"
                }
            end
        end

        if target then
            local idealDistance = math.random(8, 15)
            local toTarget = (target.Position - primaryPart.Position)
            local moveToPos = target.Position - (toTarget.Unit * idealDistance)

            local shouldJump = (primaryPart.Position - target.Position).Magnitude < 15
                and (target.Position.Y > primaryPart.Position.Y + 1.5)
                and humanoid.FloorMaterial ~= Enum.Material.Air
                and AICooldowns.jump <= 0

            if shouldJump then
                humanoid.Jump = true
                AICooldowns.jump = 0.8 + math.random() * 0.4
            end

            moveToPosition(character, moveToPos, true)
        else
            local wanderPos = primaryPart.Position + Vector3.new(math.random(-25,25), 0, math.random(-25,25))
            moveToPosition(character, wanderPos, false)
        end
    end,

    BallChaser = function(character)
        if not character then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local primaryPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        if not humanoid or not primaryPart then return end

        for k, v in pairs(AICooldowns) do
            if v > 0 then AICooldowns[k] = v - 0.1 end
        end

        local ball = getSafeBall()
        if ball then
            local predictedPos = predictPosition(ball.Position, ball.AssemblyLinearVelocity or Vector3.zero, 0.5)
            local distance = (predictedPos - primaryPart.Position).Magnitude
            local timeToReach = distance / humanoid.WalkSpeed
            local moveToPos = predictPosition(ball.Position, ball.AssemblyLinearVelocity or Vector3.zero, timeToReach * 0.7)

            if (ball.Position - primaryPart.Position).Unit:Dot((ball.AssemblyLinearVelocity or Vector3.zero).Unit) > 0.7 then
                moveToPos = ball.Position
            end

            moveToPosition(character, moveToPos, true)

            if distance < 12 and AICooldowns.jump <= 0 then
                humanoid.Jump = true
                AICooldowns.jump = 0.5 + math.random() * 0.3
            end

            if distance > 15 and AICooldowns.dash <= 0 and math.random() > 0.6 then
                humanoid:MoveTo(moveToPos)
                AICooldowns.dash = 2 + math.random()
            end
        else
            AIMethods.AdvancedPro(character)
        end
    end,

    AggressiveHunter = function(character)
        if not character then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local primaryPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        if not humanoid or not primaryPart then return end

        for k, v in pairs(AICooldowns) do
            if v > 0 then AICooldowns[k] = v - 0.1 end
        end

        local validPlayers = getValidPlayers()
        if #validPlayers > 0 then
            local closestPlayer = nil
            local closestDistance = math.huge

            for _, player in ipairs(validPlayers) do
                local distance = (primaryPart.Position - player.PrimaryPart.Position).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = player
                end
            end

            if closestPlayer then
                local predictedPos = predictPosition(
                    closestPlayer.PrimaryPart.Position,
                    closestPlayer.Velocity,
                    0.4
                )
                local flankDirection = (primaryPart.Position - predictedPos).Unit:Cross(Vector3.new(0, 1, 0))
                if math.random() > 0.5 then flankDirection = -flankDirection end
                local flankDistance = math.random(4, 10)
                local moveToPos = predictedPos + (flankDirection * flankDistance)

                if closestPlayer.PrimaryPart.Position.Y > primaryPart.Position.Y + 3 then
                    moveToPos = moveToPos + Vector3.new(0, 3, 0)
                end

                moveToPosition(character, moveToPos, true)

                if closestDistance < 15 and AICooldowns.jump <= 0 then
                    humanoid.Jump = math.random() > 0.2
                    AICooldowns.jump = 0.3 + math.random() * 0.2
                end

                if closestDistance > 10 and AICooldowns.dash <= 0 and math.random() > 0.5 then
                    humanoid:MoveTo(predictedPos)
                    AICooldowns.dash = 2 + math.random()
                end
            end
        else
            local wanderPos = primaryPart.Position + Vector3.new(math.random(-20, 20), 0, math.random(-20, 20))
            moveToPosition(character, wanderPos, false)
        end
    end
}

local function runAI()
    local lastUpdate = os.clock()
    while AIPlaying do
        local character = LocalPlayer.Character
        if character then
            local deltaTime = os.clock() - lastUpdate
            lastUpdate = os.clock()
            for k, v in pairs(AICooldowns) do
                AICooldowns[k] = math.max(0, v - deltaTime)
            end
            local success, err = pcall(function()
                if AIMethods[AICurrentMethod] then
                    AIMethods[AICurrentMethod](character)
                end
            end)
            if not success then
                warn("AI Error:", err)
                AICurrentMethod = "AdvancedPro"
                Config.ai_method = "AdvancedPro"
                WindUI:Notify({
                    Title = "AI Error",
                    Content = "Reverted to AdvancedPro due to error: " .. tostring(err),
                    Duration = 2,
                    Icon = "alert-triangle"
                })
            end
        end
        task.wait(0.1 + math.random() * 0.15)
    end
end

local tweenService = game:GetService("TweenService")
local cam = workspace.CurrentCamera
local player = game.Players.LocalPlayer

local PlayerGui = player:WaitForChild("PlayerGui", 10)
if not PlayerGui then
    warn("PlayerGui not found ngg")
    return
end
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "BallDirectionIndicatorGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Enabled = true
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = PlayerGui

local Arrow = Instance.new("ImageLabel")
Arrow.Name = "DirectionArrow"
Arrow.Size = UDim2.new(0, 50, 0, 70) 
Arrow.Position = UDim2.new(0.5, 0, 0.6, 0)
Arrow.BackgroundTransparency = 1
Arrow.Image = "rbxassetid://6664693765"
Arrow.ImageTransparency = 0
Arrow.ImageColor3 = Color3.new(1, 1, 1)
Arrow.Visible = false
Arrow.ZIndex = 100
Arrow.Parent = ScreenGui

local targetCounters = {}
local selfParryCounter = 0 -- Counter parry untuk LocalPlayer
local lastNotifyTime = {} -- Cooldown per player
local lastResetTime = tick()
local lastTarget = nil -- Lacak target sebelumnya

-- Fungsi buat cek apakah dalam game (bukan lobby)
local function isInGame()
    return LocalPlayer.Character and 
           LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and 
           workspace.Alive:FindFirstChild(LocalPlayer.Name)
end

-- Fungsi buat floating text
local function createFloatingText(parent, text, offset, isBall)
    if not parent then
        return nil
    end
    if parent:FindFirstChild("FloatingText") then
        parent.FloatingText:Destroy()
    end

    local BillboardGui = Instance.new("BillboardGui")
    BillboardGui.Name = "FloatingText"
    BillboardGui.Parent = parent
    BillboardGui.Adornee = parent
    BillboardGui.Size = UDim2.new(0, 100, 0, isBall and 20 or 40)
    BillboardGui.StudsOffset = offset or Vector3.new(0, isBall and 4.2 or 2, 0)
    BillboardGui.AlwaysOnTop = true
    BillboardGui.MaxDistance = 200 -- Jauh banget
    BillboardGui.ClipsDescendants = true

    local MainText = Instance.new("TextLabel")
    MainText.Name = "MainText"
    MainText.Size = UDim2.new(1, 0, 0.5, 0)
    MainText.Position = UDim2.new(0, 0, 0, 0)
    MainText.BackgroundTransparency = 1
    MainText.Text = text
    MainText.TextColor3 = Color3.fromRGB(255, 255, 255)
    MainText.TextSize = 14
    MainText.Font = Enum.Font.GothamBold
    MainText.TextScaled = true
    MainText.TextStrokeTransparency = 0.8
    MainText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    MainText.Parent = BillboardGui

    local StatusText = Instance.new("TextLabel")
    StatusText.Name = "StatusText"
    StatusText.Size = UDim2.new(1, 0, 0.5, 0)
    StatusText.Position = UDim2.new(0, 0, 0.5, 0)
    StatusText.BackgroundTransparency = 1
    StatusText.Text = ""
    StatusText.TextColor3 = Color3.fromRGB(255, 255, 255)
    StatusText.TextSize = 10
    StatusText.Font = Enum.Font.Gotham
    StatusText.TextScaled = true
    StatusText.TextStrokeTransparency = 0.8
    StatusText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    StatusText.Parent = BillboardGui

    return BillboardGui
end

-- Fungsi buat update warna dan status berdasarkan jarak
local function updatePlayerESP(player, billboard)
    if not Config.visuals_enabled or not isInGame() or not player:FindFirstChild("HumanoidRootPart") then
        return
    end

    local distance = (LocalPlayer.Character.HumanoidRootPart.Position - player.HumanoidRootPart.Position).Magnitude
    local mainText = billboard.MainText
    local statusText = billboard.StatusText

    if distance < 10 then
        mainText.TextColor3 = Color3.fromRGB(255, 0, 0) -- Merah
        statusText.Text = "Too Close To Player"
        statusText.TextColor3 = Color3.fromRGB(255, 0, 0)
    elseif distance < 20 then
        mainText.TextColor3 = Color3.fromRGB(255, 255, 0) -- Kuning
        statusText.Text = "Mid Distance"
        statusText.TextColor3 = Color3.fromRGB(255, 255, 0)
    else
        mainText.TextColor3 = Color3.fromRGB(0, 255, 0) -- Hijau
        statusText.Text = "Far Distance"
        statusText.TextColor3 = Color3.fromRGB(0, 255, 0)
    end

    mainText.TextTransparency = 0
    mainText.TextStrokeTransparency = 0.8
    statusText.TextTransparency = 0
    statusText.TextStrokeTransparency = 0.8

    -- Cek clash/long parry berdasarkan jarak dan parry count
    local playerName = player.Name
    local lastNotify = lastNotifyTime[playerName] or 0
    if tick() - lastNotify >= 5 then
        if distance < 20 and targetCounters[playerName] and targetCounters[playerName] >= 4 then
            WindUI:Notify({
                Title = "ESP Alert",
                Content = playerName .. " Wanna Clash With You!",
                Duration = 0.5,
            })
            lastNotifyTime[playerName] = tick()
        elseif distance >= 20 and targetCounters[playerName] and targetCounters[playerName] >= 3 and selfParryCounter >= 3 then
            WindUI:Notify({
                Title = "ESP Alert",
                Content = playerName .. " Wanna Long Parry With You!",
                Duration = 0.5,
            })
            lastNotifyTime[playerName] = tick()
        end
    end
end

-- Visuals Connection
ConnectionsManager['visuals'] = RunService.Heartbeat:Connect(function()
    if not Config.visuals_enabled or not isInGame() then
        for _, player in pairs(workspace.Alive:GetChildren()) do
            if player:FindFirstChild("FloatingText") then
                player.FloatingText:Destroy()
            end
        end
        local ball = AutoParry.get_ball()
        if ball and ball:FindFirstChild("FloatingText") then
            ball.FloatingText:Destroy()
        end
        return
    end

    -- Reset target counter tiap 5 detik
    if tick() - lastResetTime >= 5 then
        targetCounters = {}
        selfParryCounter = 0
        lastResetTime = tick()
    end

    -- Floating text buat pemain
    for _, player in pairs(workspace.Alive:GetChildren()) do
        if player ~= LocalPlayer.Character and player:FindFirstChild("HumanoidRootPart") then
            local playerName = player.Name
            local billboard = player:FindFirstChild("FloatingText")
            if not billboard or billboard.MainText.Text ~= playerName then
                billboard = createFloatingText(player.HumanoidRootPart, playerName, Vector3.new(0, 2, 0), false)
            end
            updatePlayerESP(player, billboard)
        end
    end

    -- Floating text dan targeting buat bola
    local ball = AutoParry.get_ball()
    if ball then
        if not ball:FindFirstChild("FloatingText") then
            createFloatingText(ball, "Ball", Vector3.new(0, ball.Size.Y + 1.2, 0), true)
        end

        -- Cek targeting dengan cooldown
        local target = ball:GetAttribute("target")
        if target and target ~= lastTarget then -- Cuma trigger pas target berubah
            lastTarget = target
            if target == LocalPlayer.Name then
                local lastNotify = lastNotifyTime["self"] or 0
                if tick() - lastNotify >= 5 then
                    WindUI:Notify({
                        Title = "ESP Alert",
                        Content = "You are the target!",
                        Duration = 0.5,
                    })
                    lastNotifyTime["self"] = tick()
                    selfParryCounter = selfParryCounter + 1
                end
            elseif target ~= LocalPlayer.Name and workspace.Alive:FindFirstChild(target) then
                targetCounters[target] = (targetCounters[target] or 0) + 1
                local lastNotify = lastNotifyTime[target] or 0
                if tick() - lastNotify >= 5 then
                    if targetCounters[target] == 3 then
                        WindUI:Notify({
                            Title = "ESP Warning",
                            Content = target .. " is targeting you!",
                            Duration = 0.5,
                        })
                        lastNotifyTime[target] = tick()
                    end
                end
            end
        end
    else
        lastTarget = nil -- Reset kalau bola ilang
    end
end)

-- Handle respawn bola
workspace.Balls.ChildRemoved:Connect(function(child)
    is_respawned = false
    if child == AutoParry.ball.ball_entity then
        AutoParry.ball.ball_entity = nil
        AutoParry.ball.client_ball_entity = nil
        ConnectionsManager.disconnect('on_target_change')
        AutoParry.reset()
        if child:FindFirstChild("FloatingText") then
            child.FloatingText:Destroy()
        end
        targetCounters = {} -- Reset counter
        selfParryCounter = 0
        lastTarget = nil
    end
end)

workspace.Balls.ChildAdded:Connect(function()
    if is_respawned then
        return
    end
    is_respawned = true
    local ball_properties = AutoParry.ball.properties
    ball_properties.respawn_time = tick()
    AutoParry.ball.ball_entity = AutoParry.get_ball()
    AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()
    if Config.visuals_enabled and isInGame() then
        local ball = AutoParry.get_ball()
        if ball then
            createFloatingText(ball, "Ball", Vector3.new(0, ball.Size.Y + 1.2, 0), true)
        end
    end
    ConnectionsManager['on_target_change'] = AutoParry.ball.ball_entity:GetAttributeChangedSignal('target'):Connect(function()
        if target == LocalPlayer.Name then
            ball_properties.cooldown = false
            return
        end
        ball_properties.cooldown = false
        ball_properties.old_speed = ball_properties.speed
        ball_properties.last_position = ball_properties.position
        ball_properties.parries += 1
        task.delay(0.25, function()
            if ball_properties.parries > 0 then
                ball_properties.parries -= 1
            end
        end)
    end)
end)

local CustomAnnouncer = {
    enabled = false,
    custom_text = "VicoX Top" -- Default text
}

function CustomAnnouncer:updateAnnouncer()
    if not self.enabled then return end

    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
    local announcer = playerGui:WaitForChild("announcer")
    local winner = announcer:FindFirstChild("Winner")

    if winner then
        winner.Text = self.custom_text
    end

    
    if not ConnectionsManager['announcer_child_added'] then
        ConnectionsManager['announcer_child_added'] = announcer.ChildAdded:Connect(function(child)
            if child.Name == "Winner" and CustomAnnouncer.enabled then
                child.Text = CustomAnnouncer.custom_text
                
                ConnectionsManager['announcer_text_changed'] = child.Changed:Connect(function(property)
                    if property == "Text" and CustomAnnouncer.enabled then
                        child.Text = CustomAnnouncer.custom_text
                    end
                end)
            end
        end)
    end
end

local PlayerFollow = {
    selected_player = nil,
}

function PlayerFollow:getPlayerNames()
    local names = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(names, player.Name)
        end
    end
    table.sort(names) -- Sort for consistent dropdown order
    return names
end

function PlayerFollow:startFollowing()
    if not Config.player_follow or not Config.follow_target then return end

    local targetPlayer = Players:FindFirstChild(Config.follow_target)
    if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character.PrimaryPart then return end

    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("Humanoid") then return end

    char.Humanoid:MoveTo(targetPlayer.Character.PrimaryPart.Position)
end

function PlayerFollow:updatePlayerList()
    local newOptions = self:getPlayerNames()
    local newOptionsString = table.concat(newOptions, ",")
    if newOptionsString ~= self.lastOptionsString then
        if self.dropdown then
            self.dropdown.Values = newOptions -- Update dropdown options
            if #newOptions > 0 then
                if not table.find(newOptions, Config.follow_target) then
                    Config.follow_target = newOptions[1] -- Default to first player if current target is invalid
                    self.dropdown.Value = Config.follow_target
                end
            else
                Config.follow_target = nil
            end
        end
        self.lastOptionsString = newOptionsString
    end
end

PlayerFollow.lastOptionsString = table.concat(PlayerFollow:getPlayerNames(), ",")

local BallTrail = nil
local PlayerTrail = nil
local TrailConnection = nil
local lastTrailUpdateTime = 0

local function CreateTrail(parent, color, name)
    if not parent or not parent:IsA("BasePart") then
        warn("CreateTrail: Invalid or missing parent for " .. tostring(name))
        return nil
    end

    local trail = Instance.new("Trail")
    trail.Name = name

    -- Dynamic color gradient with more keypoints for vibrant effect
    trail.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, color),
        ColorSequenceKeypoint.new(0.3, color:Lerp(Color3.fromRGB(255, 255, 255), 0.5)),
        ColorSequenceKeypoint.new(0.7, color:Lerp(Color3.fromRGB(255, 255, 0), 0.3)),
        ColorSequenceKeypoint.new(1, color:Lerp(Color3.new(0, 0, 0), 0.7))
    })

    -- Dynamic width with animation based on type
    local widthKeypoints = Config.trail_animation_type == "Pulse" and {
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(0.5, 0.5),
        NumberSequenceKeypoint.new(1, 0.2)
    } or Config.trail_animation_type == "Flicker" and {
        NumberSequenceKeypoint.new(0, 0.8),
        NumberSequenceKeypoint.new(0.25, 0.4),
        NumberSequenceKeypoint.new(0.5, 0.8),
        NumberSequenceKeypoint.new(0.75, 0.4),
        NumberSequenceKeypoint.new(1, 0.2)
    } or {
        NumberSequenceKeypoint.new(0, 0.8),
        NumberSequenceKeypoint.new(1, 0.2)
    }
    trail.WidthScale = NumberSequence.new(widthKeypoints)

    -- Smooth transparency with animation
    local transparencyKeypoints = Config.trail_animation_type == "Pulse" and {
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.5, 0.4),
        NumberSequenceKeypoint.new(1, 0.9)
    } or Config.trail_animation_type == "Flicker" and {
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.25, 0.5),
        NumberSequenceKeypoint.new(0.5, 0),
        NumberSequenceKeypoint.new(0.75, 0.5),
        NumberSequenceKeypoint.new(1, 0.9)
    } or {
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 0.8)
    }
    trail.Transparency = NumberSequence.new(transparencyKeypoints)

    -- Set texture if specified
    if Config.trail_texture == "Spark" then
        trail.Texture = "rbxassetid://299531902" -- Spark texture
    elseif Config.trail_texture == "Flame" then
        trail.Texture = "rbxassetid://243098098" -- Flame texture
    end
    trail.TextureLength = 2
    trail.Lifetime = Config.trail_animation_type == "Flicker" and 0.8 or 1.5
    trail.Enabled = true

    -- Create attachments
    local attachment0 = Instance.new("Attachment")
    attachment0.Name = name .. "Attachment0"
    attachment0.Parent = parent
    local attachment1 = Instance.new("Attachment")
    attachment1.Name = name .. "Attachment1"
    attachment1.Position = Vector3.new(0, -1.5, 0) -- Adjusted for visibility
    attachment1.Parent = parent

    trail.Attachment0 = attachment0
    trail.Attachment1 = attachment1
    trail.Parent = parent

    -- Add particle emitter if enabled
    if Config.trail_particle_enabled then
        local particle = Instance.new("ParticleEmitter")
        particle.Name = name .. "Particles"
        particle.Color = ColorSequence.new(color)
        particle.Size = NumberSequence.new(0.2)
        particle.Rate = Config.trail_particle_rate
        particle.Lifetime = NumberRange.new(0.5, 1)
        particle.Speed = NumberRange.new(2, 5)
        particle.SpreadAngle = Vector2.new(30, 30)
        particle.Texture = Config.trail_texture == "Spark" and "rbxassetid://299531902" or Config.trail_texture == "Flame" and "rbxassetid://243098098" or "rbxassetid://243660364" -- Default particle texture
        particle.Enabled = true
        particle.Parent = attachment0
        Debris:AddItem(particle, 5) -- Clean up particles after 5 seconds
    end

    return trail
end

-- Update ball trail with dynamic effects
local function UpdateBallTrail()
    if Config.ball_trail_enabled then
        local ball = AutoParry and AutoParry.get_ball and AutoParry:get_ball()
        if ball and ball:IsA("BasePart") and ball.Parent then
            if not BallTrail or BallTrail.Parent ~= ball then
                if BallTrail then
                    BallTrail:Destroy()
                    BallTrail = nil
                end
                BallTrail = CreateTrail(ball, Config.ball_trail_color, "BallTrail")
            end
            if BallTrail then
                -- Dynamic color based on ball speed
                local velocity = ball.Velocity.Magnitude
                local speedFactor = math.clamp(velocity / 50, 0, 1)
                local dynamicColor = Config.ball_trail_color:Lerp(Color3.fromRGB(255, 255, 255), speedFactor)
                BallTrail.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, dynamicColor),
                    ColorSequenceKeypoint.new(0.3, dynamicColor:Lerp(Color3.fromRGB(255, 255, 0), 0.5)),
                    ColorSequenceKeypoint.new(0.7, dynamicColor:Lerp(Color3.fromRGB(255, 0, 0), 0.3)),
                    ColorSequenceKeypoint.new(1, dynamicColor:Lerp(Color3.new(0, 0, 0), 0.7))
                })
                BallTrail.Enabled = true
            end
        else
            if BallTrail then
                BallTrail:Destroy()
                BallTrail = nil
            end
        end
    else
        if BallTrail then
            BallTrail:Destroy()
            BallTrail = nil
        end
    end
end

-- Update player trail with dynamic effects
local function UpdatePlayerTrail()
    if Config.player_trail_enabled then
        local character = LocalPlayer.Character
        local hrp = character and (character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart)
        if hrp and hrp:IsA("BasePart") and hrp.Parent then
            if not PlayerTrail or PlayerTrail.Parent ~= hrp then
                if PlayerTrail then
                    PlayerTrail:Destroy()
                    PlayerTrail = nil
                end
                PlayerTrail = CreateTrail(hrp, Config.player_trail_color, "PlayerTrail")
            end
            if PlayerTrail then
                -- Dynamic color based on time for pulsing effect
                local timeFactor = math.sin(tick() * 2) * 0.5 + 0.5
                local dynamicColor = Config.player_trail_color:Lerp(Color3.fromRGB(255, 255, 255), timeFactor)
                PlayerTrail.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, dynamicColor),
                    ColorSequenceKeypoint.new(0.3, dynamicColor:Lerp(Color3.fromRGB(0, 255, 255), 0.5)),
                    ColorSequenceKeypoint.new(0.7, dynamicColor:Lerp(Color3.fromRGB(0, 0, 255), 0.3)),
                    ColorSequenceKeypoint.new(1, dynamicColor:Lerp(Color3.new(0, 0, 0), 0.7))
                })
                PlayerTrail.Enabled = true
            end
        else
            if PlayerTrail then
                PlayerTrail:Destroy()
                PlayerTrail = nil
            end
        end
    else
        if PlayerTrail then
            PlayerTrail:Destroy()
            PlayerTrail = nil
        end
    end
end

local function StartTrailUpdate()
    if TrailConnection then
        TrailConnection:Disconnect()
        TrailConnection = nil
    end
    TrailConnection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        if currentTime - lastTrailUpdateTime < 0.05 then return end -- Throttle updates to 20 FPS
        lastTrailUpdateTime = currentTime
        pcall(UpdateBallTrail)
        pcall(UpdatePlayerTrail)
    end)
end

local function StopTrailUpdate()
    if TrailConnection then
        TrailConnection:Disconnect()
        TrailConnection = nil
    end
    if BallTrail then
        BallTrail:Destroy()
        BallTrail = nil
    end
    if PlayerTrail then
        PlayerTrail:Destroy()
        PlayerTrail = nil
    end
end

if Config.ball_trail_enabled or Config.player_trail_enabled then
    task.spawn(StartTrailUpdate)
end

do
        local getServiceFunction = game.GetService
        
        local function getClonerefPermission()
            local permission = cloneref(getServiceFunction(game, "ReplicatedFirst"))
            return permission
        end
        
        AutoPlayModule.clonerefPermission = getClonerefPermission()
        
        if not AutoPlayModule.clonerefPermission then
            warn("cloneref is not available on your executor! There is a risk of getting detected.")
        end
        
        function AutoPlayModule.findCachedService(self, name)
            for index, value in self do
                if value.Name == name then
                    return value
                end
            end
            return
        end
        
        function AutoPlayModule.getService(self, name)
            local cachedService = AutoPlayModule.findCachedService(self, name)
        
            if cachedService then
                return cachedService
            end
        
            local service = getServiceFunction(game, name)
        
            if AutoPlayModule.clonerefPermission then
                service = cloneref(service)
            end
        
            table.insert(self, service)
            return service
        end
        
        AutoPlayModule.customService = setmetatable({}, {
            __index = AutoPlayModule.getService
        })
    end
    
    AutoPlayModule.playerHelper = {
        isAlive = function(player)
            local character = nil
        
            if player and player:IsA("Player") then
                character = player.Character
            end
        
            if not character then
                return false
            end
        
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChild("Humanoid")
        
            if not rootPart or not humanoid then
                return false
            end
        
            return humanoid.Health > 0
        end,
        
        inLobby = function(character)
            if not character then
                return false
            end
        
            return character.Parent == AutoPlayModule.customService.Workspace.Dead
        end,
        
        onGround = function(character)
            if not character then
                return false
            end
        
            return character.Humanoid.FloorMaterial ~= Enum.Material.Air
        end
    }
    
    function AutoPlayModule.isLimited()
        local passedTime = tick() - AutoPlayModule.LAST_GENERATION
        return passedTime < AutoPlayModule.CONFIG.GENERATION_THRESHOLD
    end
    
    function AutoPlayModule.percentageCheck(limit)
        if AutoPlayModule.isLimited() then
            return false
        end
    
        local percentage = math.random(100)
        AutoPlayModule.LAST_GENERATION = tick()
    
        return limit >= percentage
    end

    AutoPlayModule.ballUtils = {
        getBall = function()
            for _, object in AutoPlayModule.customService.Workspace.Balls:GetChildren() do
                if object:GetAttribute("realBall") then
                    AutoPlayModule.ball = object
                    return
                end
            end
        
            AutoPlayModule.ball = nil
        end,
        
        getDirection = function()
            if not AutoPlayModule.ball then
                return
            end
        
            local direction = (AutoPlayModule.customService.Players.LocalPlayer.Character.HumanoidRootPart.Position - AutoPlayModule.ball.Position).Unit
            return direction
        end,
        
        getVelocity = function()
            if not AutoPlayModule.ball then
                return
            end
        
            local zoomies = AutoPlayModule.ball:FindFirstChild("zoomies")
        
            if not zoomies then
                return
            end
        
            return zoomies.VectorVelocity
        end,
        
        getSpeed = function()
            local velocity = AutoPlayModule.ballUtils.getVelocity()
        
            if not velocity then
                return
            end
        
            return velocity.Magnitude
        end,
        
        isExisting = function()
            return AutoPlayModule.ball ~= nil
        end
    }
    
    AutoPlayModule.lerp = function(start, finish, alpha)
        return start + (finish - start) * alpha
    end
    
    AutoPlayModule.quadratic = function(start, middle, finish, alpha)
        local firstLerp = AutoPlayModule.lerp(start, middle, alpha)
        local secondLerp = AutoPlayModule.lerp(middle, finish, alpha)
    
        return AutoPlayModule.lerp(firstLerp, secondLerp, alpha)
    end
    
    AutoPlayModule.getCandidates = function(middle, theta, offsetLength)
        local firstCanditateX = math.cos(theta + math.pi / 2)
        local firstCanditateZ = math.sin(theta + math.pi / 2)
        local firstCandidate = middle + Vector3.new(firstCanditateX, 0, firstCanditateZ) * offsetLength
    
        local secondCanditateX = math.cos(theta - math.pi / 2)
        local secondCanditateZ = math.sin(theta - math.pi / 2)
        local secondCandidate = middle + Vector3.new(secondCanditateX, 0, secondCanditateZ) * offsetLength
    
        return firstCandidate, secondCandidate
    end
    
    AutoPlayModule.getControlPoint = function(start, finish)
        local middle = (start + finish) * 0.5
        local difference = start - finish
    
        if difference.Magnitude < 5 then
            return finish
        end
    
        local theta = math.atan2(difference.Z, difference.X)
        local offsetLength = difference.Magnitude * AutoPlayModule.CONFIG.OFFSET_FACTOR
    
        local firstCandidate, secondCandidate = AutoPlayModule.getCandidates(middle, theta, offsetLength)
        local dotValue = start - middle
    
        if (firstCandidate - middle):Dot(dotValue) < 0 then
            return firstCandidate
        else
            return secondCandidate
        end
    end
    
    AutoPlayModule.getCurve = function(start, finish, delta)
        AutoPlayModule.ELAPSED = AutoPlayModule.ELAPSED + delta
        local timeElapsed = math.clamp(AutoPlayModule.ELAPSED / AutoPlayModule.CONFIG.MOVEMENT_DURATION, 0, 1)
    
        if timeElapsed >= 1 then
            local distance = (start - finish).Magnitude
    
            if distance >= 10 then
                AutoPlayModule.ELAPSED = 0
            end
    
            AutoPlayModule.CONTROL_POINT = nil
            return finish
        end
    
        if not AutoPlayModule.CONTROL_POINT then
            AutoPlayModule.CONTROL_POINT = AutoPlayModule.getControlPoint(start, finish)
        end
    
        assert(AutoPlayModule.CONTROL_POINT, "CONTROL_POINT: Vector3 expected, got nil")
        return AutoPlayModule.quadratic(start, AutoPlayModule.CONTROL_POINT, finish, timeElapsed)
    end
    
    AutoPlayModule.map = {
        getFloor = function()
            local floor = AutoPlayModule.customService.Workspace:FindFirstChild("FLOOR")
            
            if not floor then
                for _, part in pairs(AutoPlayModule.customService.Workspace:GetDescendants()) do
                    if part:IsA("MeshPart") or part:IsA("BasePart") then
                        local size = part.Size
                        if size.X > 50 and size.Z > 50 and part.Position.Y < 5 then
                            return part
                        end
                    end
                end
            end
            
            return floor
        end
    }
    
    AutoPlayModule.getRandomPosition = function()
        local floor = AutoPlayModule.map.getFloor()
    
        if not floor or not AutoPlayModule.ballUtils.isExisting() then
            return
        end
    
        local ballDirection = AutoPlayModule.ballUtils.getDirection() * AutoPlayModule.CONFIG.DIRECTION
        local ballSpeed = AutoPlayModule.ballUtils.getSpeed()
    
        local speedThreshold = math.min(ballSpeed / 10, AutoPlayModule.CONFIG.MULTIPLIER_THRESHOLD)
        local speedMultiplier = AutoPlayModule.CONFIG.DEFAULT_DISTANCE + speedThreshold
        local negativeDirection = ballDirection * speedMultiplier
    
        local currentTime = os.time() / 1.2
        local sine = math.sin(currentTime) * AutoPlayModule.CONFIG.TRAVERSING
        local cosine = math.cos(currentTime) * AutoPlayModule.CONFIG.TRAVERSING
    
        local traversing = Vector3.new(sine, 0, cosine)
        local finalPosition = floor.Position + negativeDirection + traversing
    
        return finalPosition
    end
    
    
    AutoPlayModule.lobby = {
        isChooserAvailable = function()
            return AutoPlayModule.customService.Workspace.Spawn.NewPlayerCounter.GUI.SurfaceGui.Top.Options.Visible
        end,
        
        updateChoice = function(choice)
            AutoPlayModule.lobbyChoice = choice
        end,
        
        getMapChoice = function()
            local choice = AutoPlayModule.lobbyChoice or math.random(1, 3)
            local collider = AutoPlayModule.customService.Workspace.Spawn.NewPlayerCounter.Colliders:FindFirstChild(choice)
        
            return collider
        end,
        
        getPadPosition = function()
            if not AutoPlayModule.lobby.isChooserAvailable() then
                AutoPlayModule.lobbyChoice = nil
                return
            end
        
            local choice = AutoPlayModule.lobby.getMapChoice()
        
            if not choice then
                return
            end
        
            return choice.Position, choice.Name
        end
    }
    
    AutoPlayModule.movement = {
        removeCache = function()
            if AutoPlayModule.animationCache then
                AutoPlayModule.animationCache = nil
            end
        end,
        
        createJumpVelocity = function(player)
            local maxForce = math.huge
            local velocity = Instance.new("BodyVelocity")
            velocity.MaxForce = Vector3.new(maxForce, maxForce, maxForce)
            velocity.Velocity = Vector3.new(0, 80, 0)
            velocity.Parent = player.Character.HumanoidRootPart
        
            AutoPlayModule.customService.Debris:AddItem(velocity, 0.001)
            AutoPlayModule.customService.ReplicatedStorage.Remotes.DoubleJump:FireServer()
        end,
        
        playJumpAnimation = function(player)
            if not AutoPlayModule.animationCache then
                local doubleJumpAnimation = AutoPlayModule.customService.ReplicatedStorage.Assets.Tutorial.Animations.DoubleJump
                AutoPlayModule.animationCache = player.Character.Humanoid.Animator:LoadAnimation(doubleJumpAnimation)
            end
        
            if AutoPlayModule.animationCache then
                AutoPlayModule.animationCache:Play()
            end
        end,
        
        doubleJump = function(player)
            if AutoPlayModule.doubleJumped then
                return
            end
        
            if not AutoPlayModule.percentageCheck(AutoPlayModule.CONFIG.DOUBLE_JUMP_PERCENTAGE) then
                return
            end
        
            AutoPlayModule.doubleJumped = true
            AutoPlayModule.movement.createJumpVelocity(player)
            AutoPlayModule.movement.playJumpAnimation(player)
        end,
        
        jump = function(player)
            if not AutoPlayModule.CONFIG.JUMPING_ENABLED then
                return
            end
            
            if not AutoPlayModule.playerHelper.onGround(player.Character) then
                AutoPlayModule.movement.doubleJump(player)
                return
            end
        
            if not AutoPlayModule.percentageCheck(AutoPlayModule.CONFIG.JUMP_PERCENTAGE) then
                return
            end
        
            AutoPlayModule.doubleJumped = false
            player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end,
        
        move = function(player, playerPosition)
            player.Character.Humanoid:MoveTo(playerPosition)
        end,
        
        stop = function(player)
            local playerPosition = player.Character.HumanoidRootPart.Position
            player.Character.Humanoid:MoveTo(playerPosition)
        end
    }
    
    AutoPlayModule.signal = {
        connect = function(name, connection, callback)
            if not name then
                name = AutoPlayModule.customService.HttpService:GenerateGUID()
            end
        
            AutoPlayModule.signals[name] = connection:Connect(callback)
            return AutoPlayModule.signals[name]
        end,
        
        disconnect = function(name)
            if not name or not AutoPlayModule.signals[name] then
                return
            end
        
            AutoPlayModule.signals[name]:Disconnect()
            AutoPlayModule.signals[name] = nil
        end,
        
        stop = function()
            for name, connection in pairs(AutoPlayModule.signals) do
                if typeof(connection) ~= "RBXScriptConnection" then
                    continue
                end
        
                connection:Disconnect()
                AutoPlayModule.signals[name] = nil
            end
        end
    }
    
    AutoPlayModule.findPath = function(inLobby, delta)
        local rootPosition = AutoPlayModule.customService.Players.LocalPlayer.Character.HumanoidRootPart.Position
    
        if inLobby then
            local padPosition, padNumber = AutoPlayModule.lobby.getPadPosition()
            local choice = tonumber(padNumber)
            if choice then
                AutoPlayModule.lobby.updateChoice(choice)
                if getgenv().AutoVote then
                    game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.1.0"):WaitForChild("net"):WaitForChild("RE/UpdateVotes"):FireServer("FFA")
                end
            end
    
            if not padPosition then
                return
            end
    
            return AutoPlayModule.getCurve(rootPosition, padPosition, delta)
        end
    
        local randomPosition = AutoPlayModule.getRandomPosition()
    
        if not randomPosition then
            return
        end
    
        return AutoPlayModule.getCurve(rootPosition, randomPosition, delta)
    end
    
    
    AutoPlayModule.followPath = function(delta)
        if not AutoPlayModule.playerHelper.isAlive(AutoPlayModule.customService.Players.LocalPlayer) then
            AutoPlayModule.movement.removeCache()
            return
        end
    
        local inLobby = AutoPlayModule.customService.Players.LocalPlayer.Character.Parent == AutoPlayModule.customService.Workspace.Dead
        local path = AutoPlayModule.findPath(inLobby, delta)
    
        if not path then
            AutoPlayModule.movement.stop(AutoPlayModule.customService.Players.LocalPlayer)
            return
        end
    
        AutoPlayModule.movement.move(AutoPlayModule.customService.Players.LocalPlayer, path)
        AutoPlayModule.movement.jump(AutoPlayModule.customService.Players.LocalPlayer)
    end
    
    AutoPlayModule.finishThread = function()
        AutoPlayModule.signal.disconnect("auto-play")
        AutoPlayModule.signal.disconnect("synchronize")
        
        if not AutoPlayModule.playerHelper.isAlive(AutoPlayModule.customService.Players.LocalPlayer) then
            return
        end
        
        AutoPlayModule.movement.stop(AutoPlayModule.customService.Players.LocalPlayer)
    end
    
    AutoPlayModule.runThread = function()
        AutoPlayModule.signal.connect("auto-play", AutoPlayModule.customService.RunService.PostSimulation, AutoPlayModule.followPath)
        AutoPlayModule.signal.connect("synchronize", AutoPlayModule.customService.RunService.PostSimulation, AutoPlayModule.ballUtils.getBall)
    end





local function setupVisualRing()
    -- Configuration
    Config.visual_ring = false -- Default: disabled

    -- Ring untuk Spam Range
    local spamRing = Instance.new("Part")
    spamRing.Anchored = true
    spamRing.CanCollide = false
    spamRing.Transparency = 0.2
    spamRing.CastShadow = false
    spamRing.Size = Vector3.new(2, 2, 2) -- Ukuran dasar sesuai kode terbaru
    spamRing.Parent = Workspace

    local spamRingMesh = Instance.new("SpecialMesh", spamRing)
    spamRingMesh.MeshId = "rbxassetid://79874370541467" -- ID mesh dari kode terbaru
    spamRingMesh.TextureId = ""
    spamRingMesh.Scale = Vector3.new(1, 1, 1)

    -- Ring untuk Parry Range
    local parryRing = Instance.new("Part")
    parryRing.Anchored = true
    parryRing.CanCollide = false
    parryRing.Transparency = 0.3
    parryRing.CastShadow = false
    parryRing.Size = Vector3.new(2, 2, 2) -- Ukuran dasar sesuai kode terbaru
    parryRing.Parent = Workspace

    local parryRingMesh = Instance.new("SpecialMesh", parryRing)
    parryRingMesh.MeshId = "rbxassetid://105747096053609" -- ID mesh dari kode terbaru
    parryRingMesh.TextureId = ""
    parryRingMesh.Scale = Vector3.new(1, 1, 1)

    local function getCharacter()
        return LocalPlayer.Character or nil
    end

    local function getPrimaryPart()
        local char = getCharacter()
        return char and char:FindFirstChild("HumanoidRootPart") or nil
    end

    local function getActiveBall()
        local ballCont = Workspace:FindFirstChild("Balls")
        if not ballCont then 
            return nil 
        end
        for _, b in ipairs(ballCont:GetChildren()) do
            if not b.Anchored and b:IsA("BasePart") then 
                return b 
            end
        end
        return nil
    end

    ConnectionsManager['visual_ring'] = RunService.RenderStepped:Connect(function()
        if not Config.visual_ring then
            spamRingMesh.Scale = Vector3.new(0, 0, 0)
            parryRingMesh.Scale = Vector3.new(0, 0, 0)
            spamRing.Transparency = 1
            parryRing.Transparency = 1
            return
        end

        local prim = getPrimaryPart()
        local ball = getActiveBall()
        
        if prim and ball and AutoParry and AutoParry.ball and AutoParry.ball.properties then
            local spamRange = AutoParry.ball.properties.spam_range or 10 -- Fallback
            local parryRange = AutoParry.ball.properties.parry_range or 10 -- Fallback

            -- Spam Ring
            spamRingMesh.Scale = Vector3.new(spamRange, spamRange, spamRange) * 0.1
            local direction = ball.Velocity.Unit
            local lookAtPos = prim.Position + direction * 5
            spamRing.CFrame = CFrame.new(prim.Position + Vector3.new(0, 0.5, 0), lookAtPos) -- Offset kecil ke atas
            spamRing.Transparency = 0.2
            if AutoParry.ball.properties.auto_spam then
                spamRing.Color = Color3.new(1, 0, 0) -- Merah untuk auto_spam
                spamRingMesh.Scale = Vector3.new(30, 30, 30) * 8
            elseif not (AutoParry.target.current and AutoParry.target.current ~= LocalPlayer.Character) then
                spamRing.Color = Color3.new(0, 1, 0) -- Hijau untuk kondisi normal
            elseif AutoParry.ball.properties.distance < AutoParry.ball.properties.parry_range then
                spamRing.Color = Color3.new(0, 0, 0) -- Hitam jika jarak < parry_range
            else
                spamRing.Color = Color3.new(1, 1, 1) -- Putih untuk kondisi lain
            end

            -- Parry Ring
            parryRingMesh.Scale = Vector3.new(parryRange, parryRange, parryRange) * 0.2 
            parryRing.CFrame = CFrame.new(prim.Position + Vector3.new(0, -0.5, 0), lookAtPos) -- Offset kecil ke bawah
            parryRing.Transparency = 0.3
            parryRing.Color = Color3.new(0, 1, 0) -- Hijau untuk parry range
            if AutoParry.ball.properties.auto_spam then
                parryRing.Color = Color3.new(1, 0, 0) -- Merah untuk auto_spam
                parryRingMesh.Scale = Vector3.new(30, 30, 30) * 5
            end
        else
            spamRingMesh.Scale = Vector3.new(0, 0, 0)
            parryRingMesh.Scale = Vector3.new(0, 0, 0)
            spamRing.Transparency = 1
            parryRing.Transparency = 1
        end
    end)

    local function cleanup()
        if spamRing and spamRing.Parent then
            spamRing:Destroy()
            spamRing = nil
        end
        if parryRing and parryRing.Parent then
            parryRing:Destroy()
            parryRing = nil
        end
        if ConnectionsManager['visual_ring'] then
            ConnectionsManager['visual_ring']:Disconnect()
            ConnectionsManager['visual_ring'] = nil
        end
    end

    local originalAbadone = ConnectionsManager.abadone
    ConnectionsManager.abadone = function()
        originalAbadone()
        cleanup()
    end
end

setupVisualRing()
         


local function setupPlushie()
  
    local plushie_temp = Instance.new("Folder")
    plushie_temp.Name = "PlushieTemp"
    plushie_temp.Parent = Workspace

    
    local plushie_data = {
        Miku = { 
            MeshId = "rbxassetid://7749007933", 
            TextureId = "rbxassetid://7749008046", 
            Scale = Vector3.new(0.2, 0.2, 0.2), -- Lebih kecil lagi
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        SpongeBob = { 
            MeshId = "rbxassetid://5343759781", 
            TextureId = "rbxassetid://5343759854", 
            Scale = Vector3.new(0.8, 0.8, 0.8), -- Tetap
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Patrick = { 
            MeshId = "rbxassetid://5730253467", 
            TextureId = "rbxassetid://5730253510", 
            Scale = Vector3.new(0.4, 0.4, 0.4), -- Lebih kecil lagi
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Sonic = { 
            MeshId = "rbxassetid://5458555841", 
            TextureId = "rbxassetid://5458555873", 
            Scale = Vector3.new(1, 1, 1), -- Tidak diubah
            Angles = CFrame.Angles(0, math.rad(90), 0) -- Tetap
        },
        Shion = { 
            MeshId = "rbxassetid://5701509472", 
            TextureId = "rbxassetid://5701509496", 
            Scale = Vector3.new(2, 2, 2), -- Lebih besar lagi
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Kaito = { 
            MeshId = "rbxassetid://7749025144", 
            TextureId = "rbxassetid://7749025177", 
            Scale = Vector3.new(0.2, 0.2, 0.2), -- Standar, bisa disesuaikan
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Reimu = { 
            MeshId = "rbxassetid://12189551557", 
            TextureId = "rbxassetid://12189551941", 
            Scale = Vector3.new(0.6, 0.6, 0.6), -- Standar, bisa disesuaikan
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Len = { 
            MeshId = "rbxassetid://7749022295", 
            TextureId = "rbxassetid://7749022336", 
            Scale = Vector3.new(0.2, 0.2, 0.2), -- Standar, bisa disesuaikan
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        },
        Bear = { 
            MeshId = "rbxassetid://12218321", 
            TextureId = "rbxassetid://12218077", 
            Scale = Vector3.new(1, 1, 1), -- Standar, bisa disesuaikan
            Angles = CFrame.Angles(0, math.rad(90), 0) -- Menghadap ke depan
        },
        Frieren = { 
            MeshId = "rbxassetid://18730983304", 
            TextureId = "rbxassetid://18730984922", 
            Scale = Vector3.new(5, 5, 5), -- Standar, bisa disesuaikan
            Angles = CFrame.Angles(0, 0, 0) -- Menghadap ke depan
        }
    }

    -- Nama unik untuk setiap boneka
    local names_map = {
        Miku = "MikuPlushie",
        SpongeBob = "SpongeBobPlushie",
        Patrick = "PatrickPlushie",
        Sonic = "SonicPlushie",
        Shion = "ShionPlushie",
        Kaito = "KaitoPlushie",
        Reimu = "ReimuPlushie",
        Len = "LenPlushie",
        Bear = "BearPlushie",
        Frieren = "FrierenPlushie"
    }

    local function clear_all_plushies()
        if #plushie_temp:GetChildren() == 0 then
            return
        end
        for _, mesh in plushie_temp:GetChildren() do
            Debris:AddItem(mesh, 0)
        end
    end

    local function create_animation(part, tweenInfo, properties)
        local tween = TweenService:Create(part, tweenInfo, properties)
        tween:Play()
        return tween
    end

    local function getCharacter()
        return LocalPlayer.Character or nil
    end

    local function getPrimaryPart()
        local char = getCharacter()
        return char and char:FindFirstChild("HumanoidRootPart") or nil
    end

    ConnectionsManager['plushie'] = RunService.RenderStepped:Connect(function()
        if not Config.plushie_enabled then
            clear_all_plushies()
            return
        end

        if not getCharacter() or not getPrimaryPart() then
            clear_all_plushies()
            return
        end

        local selected_plushie = Config.plushie_type
        local protected_name = names_map[selected_plushie] or "DefaultPlushie"

        if plushie_temp:FindFirstChild(protected_name) then
            local plushie = plushie_temp[protected_name]
            local target_CFrame = getPrimaryPart().CFrame
                * CFrame.new(Vector3.new(-2 - math.cos(tick() / 2), 6.5 + math.cos(tick() / 2), -2 - math.sin(tick() / 2)))
                * (plushie_data[selected_plushie] and plushie_data[selected_plushie].Angles or CFrame.Angles(0, 0, 0))

            create_animation(plushie, TweenInfo.new(1.45), {
                CFrame = target_CFrame
            })
        else
            clear_all_plushies()

            if plushie_data[selected_plushie] then
                local plushie = Instance.new("Part")
                plushie.Anchored = true
                plushie.CanCollide = false
                plushie.Size = Vector3.new(2, 2, 2) -- Ukuran dasar
                plushie.Transparency = 0
                plushie.Name = protected_name
                plushie.Parent = plushie_temp

                local mesh = Instance.new("SpecialMesh", plushie)
                mesh.MeshId = plushie_data[selected_plushie].MeshId
                mesh.TextureId = plushie_data[selected_plushie].TextureId
                mesh.Scale = plushie_data[selected_plushie].Scale -- Skala khusus per boneka
            end
        end
    end)

    local function cleanup()
        clear_all_plushies()
        if plushie_temp and plushie_temp.Parent then
            plushie_temp:Destroy()
            plushie_temp = nil
        end
 
        if ConnectionsManager['plushie'] then
            ConnectionsManager['plushie']:Disconnect()
            ConnectionsManager['plushie'] = nil
        end
    end

    local originalAbadone = ConnectionsManager.abadone
    ConnectionsManager.abadone = function()
        originalAbadone()
        cleanup()
    end
end

setupPlushie() 


function Player:claim_rewards()
    if not Config.auto_rewards then return end
    repeat
        task.wait(1)
    until not AutoParry.ball.properties.auto_spam
    local net = ReplicatedStorage:WaitForChild("Packages")['_Index']['sleitnick_net@0.1.0'].net
    ReplicatedStorage:WaitForChild("Remote"):WaitForChild("RemoteEvent"):FireServer('ClaimLoginReward')
    task.defer(function()
        for day = 1, 30 do
            task.wait()
            ReplicatedStorage.Remote.RemoteFunction:InvokeServer('ClaimNewDailyLoginReward', day)
            net:WaitForChild("RE/SummerWheel/ProcessRoll"):FireServer()
            net:WaitForChild("RE/SummerWheel/ClaimReward"):FireServer()
            net:WaitForChild("RE/ProcessTournamentEventRoll"):FireServer()
            net:WaitForChild("RE/CyborgWheel/ProcessRoll"):FireServer()
            net:WaitForChild("RE/SynthWheel/ProcessRoll"):FireServer()
            net:WaitForChild("RE/ProcessTournamentRoll"):FireServer()
            net:WaitForChild("RE/RolledReturnCrate"):FireServer()
            net:WaitForChild("RE/ProcessLTMRoll"):FireServer()
        end
    end)
    task.defer(function()
        for reward = 1, 6 do
            net:WaitForChild("RF/ClaimPlaytimeReward"):InvokeServer(reward)
            net:WaitForChild("RE/ClaimSeasonPlaytimeReward"):FireServer(reward)
            ReplicatedStorage:WaitForChild("Remote"):WaitForChild("RemoteFunction"):InvokeServer('SpinWheel')
            net:WaitForChild("RE/SpinFinished"):FireServer()
        end
    end)
    task.defer(function()
        for reward = 1, 5 do
            net:WaitForChild("RF/RedeemQuestsType"):InvokeServer('SummerClashEvent', 'Daily', reward)
        end
    end)
    task.defer(function()
        for reward = 1, 4 do
            net:WaitForChild("RE/SummerWheel/ClaimStreakReward"):FireServer(reward)
        end
    end)
    -- New: Additional reward claiming
    task.defer(function()
        net:WaitForChild("RF/RedeemQuestsType"):InvokeServer("Battlepass", "Weekly")
        net:WaitForChild("RF/RedeemQuestsType"):InvokeServer("Battlepass", "Daily")
        net:WaitForChild("RF/ClaimAllDailyMissions"):InvokeServer("Daily")
        net:WaitForChild("RF/ClaimAllDailyMissions"):InvokeServer("Weekly")
        net:WaitForChild("RF/ClaimAllClanBPQuests"):InvokeServer()
        local joinTimestamp = tonumber(LocalPlayer:GetAttribute("JoinedTimestamp")) + 10
        for i = 1, 6 do
            while workspace:GetServerTimeNow() < joinTimestamp + (i * 300) + 1 do
                task.wait(1)
                if not Config.auto_rewards then
                    return
                end
            end
            net:WaitForChild("RF/ClaimPlaytimeReward"):InvokeServer(i)
        end
    end)
end



-- Disable Quantum Effects
ConnectionsManager['disable_quantum_effects'] = RunService.PostSimulation:Connect(function()
    local disable_quantum_enabled = Config.disable_quantum_effects
    if not disable_quantum_enabled then
        for _, v in pairs(getconnections(ReplicatedStorage.Remotes.QuantumArena.OnClientEvent)) do
            v:Enable()
        end
        return
    end
    task.spawn(function()
        while task.wait() and Config.disable_quantum_effects do
            for _, v in pairs(getconnections(ReplicatedStorage.Remotes.QuantumArena.OnClientEvent)) do
                v:Disable()
            end
        end
    end)
end)

-- Play a cool kill effect with dynamic animations
function play_kill_effect(Part)
    if not Part or not Part:IsA("BasePart") then
        warn("play_kill_effect: Invalid or missing Part")
        return
    end

    task.defer(function()
        local success, bell = pcall(function()
            return game:GetObjects("rbxassetid://17519762269")[1]
        end)
        if not success or not bell then
            if WindUI and WindUI.Notify then
                WindUI:Notify({
                    Title = "Kill Effect Error",
                    Content = "Failed to load bell model",
                    Duration = 5,
                    Icon = "alert-triangle"
                })
            end
            return
        end

        bell.Name = 'Yeat_BELL'
        bell.Parent = workspace

        -- Scale the bell
        local scaleFactor = Config.kill_effect_scale
        bell:ScaleTo(scaleFactor)

        -- Set initial position
        bell.Position = Part.Position + Vector3.new(0, 10, 0)

        -- Play sound if available
        local bellSound = bell:FindFirstChild("Sound")
        if bellSound then
            bellSound:Play()
        end

        local TweenService = game:GetService("TweenService")
        local animationType = Config.kill_effect_animation

        -- Add particle emitter for dramatic effect
        local particle = Instance.new("ParticleEmitter")
        particle.Name = "KillEffectParticles"
        particle.Color = ColorSequence.new(Color3.fromRGB(255, 215, 0))
        particle.Size = NumberSequence.new(0.5 * scaleFactor)
        particle.Rate = 20
        particle.Lifetime = NumberRange.new(0.5, 1)
        particle.Speed = NumberRange.new(5, 10)
        particle.SpreadAngle = Vector2.new(45, 45)
        particle.Texture = "rbxassetid://243660364" -- Sparkle particle
        particle.Parent = bell
        particle.Enabled = true
        Debris:AddItem(particle, 5)

        -- Animation based on type
        if animationType == "Spiral" then
            -- Spiral upward with rotation
            local tween1 = TweenService:Create(bell, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                Position = Part.Position + Vector3.new(0, 20, 0),
                Orientation = Vector3.new(0, 360, 0)
            })
            local tween2 = TweenService:Create(bell, TweenInfo.new(1.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {
                Position = Part.Position + Vector3.new(0, 50, 0),
                Orientation = Vector3.new(0, 720, 0)
            })
            tween1:Play()
            task.delay(1, function()
                tween2:Play()
            end)
        elseif animationType == "Pulse" then
            -- Pulsing scale and upward movement
            local tween1 = TweenService:Create(bell, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 2, true), {
                CFrame = CFrame.new(Part.Position + Vector3.new(0, 15, 0)) * CFrame.Angles(0, math.rad(45), 0)
            })
            local tween2 = TweenService:Create(bell, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
                Size = Vector3.new(1, 1, 1) * scaleFactor * 1.5
            })
            local tween3 = TweenService:Create(bell, TweenInfo.new(2, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
                Position = Part.Position + Vector3.new(0, 40, 0)
            })
            tween1:Play()
            tween2:Play()
            task.delay(0.5, function()
                tween3:Play()
            end)
        else -- Linear
            -- Smooth upward movement with slight rotation
            local tween1 = TweenService:Create(bell, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                Position = Part.Position + Vector3.new(0, 20, 0),
                Orientation = Vector3.new(0, 90, 0)
            })
            local tween2 = TweenService:Create(bell, TweenInfo.new(1.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
                Position = Part.Position + Vector3.new(0, 50, 0),
                Orientation = Vector3.new(0, 180, 0)
            })
            tween1:Play()
            task.delay(1, function()
                tween2:Play()
            end)
        end

        -- Color transition
        local primaryPart = bell:IsA("Model") and bell.PrimaryPart or bell
        if primaryPart then
            local tweenColor = TweenService:Create(primaryPart, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                BrickColor = BrickColor.new("Really red")
            })
            tweenColor:Play()
        end

        -- Clean up
        Debris:AddItem(bell, 6)
    end)
end

-- Monitor player deaths for kill effect
task.defer(function()
    ConnectionsManager['kill_effect'] = workspace.Alive.ChildRemoved:Connect(function(child)
        if not Config.kill_effect then return end
        if not workspace.Dead:FindFirstChild(child.Name) then return end
        local hrp = child:FindFirstChild("HumanoidRootPart")
        if hrp then
            pcall(function()
                play_kill_effect(hrp)
            end)
        end
    end)
end)

Tabs.Home:Paragraph({
    Title = "VicoX - BladeBall (V.Premium-Moderate)",
    Desc = "hello... im back. i guess?",
    Image = "https://play-lh.googleusercontent.com/7cIIPlWm4m7AGqVpEsIfyL-HW4cQla4ucXfcQalMft1TMIYQIlf2vqgmthlZgbNAQoaQ",
    ImageSize = 42,
    Thumbnail = "rbxassetid://124408123120792",
    ThumbnailSize = 120
})

Tabs.Home:Paragraph({
    Title = "Features Here! ",
    Desc = [[
         AutoParry: Automatically parry the ball with insane timing, making you a pro! (Good ping = more OP)
         AutoSpam: Spam skills effortlessly, just turn it on and confuse your opponents!
         AutoCurve: Make your parry smoother with curve movements, featuring 12 methods!
         Skin Changer: Change sword skins to your liking, flex custom skins to stand out!
         Background Music: Play with music, choose from 15 cool tracks (Lo-Fi, Vaporwave, etc.) + adjust volume & loop.
         Ball Direction Indicator: Know where the ball is going, no more falling for traps!
         Visualizer V2: See parry range with cool visuals, making gameplay more tactical.
         Camera Lock To Ball: Camera locks onto the ball, choose ThirdPerson, TopDown, or SideView modes!
         Text Debug: Ball & player info displayed on-screen, perfect for analysis enthusiasts.
         Ball & Player Trail: Add colorful trails to the ball and character, with custom colorpicker!
         No Render & Smart Render: Lighten the game, focus on gameplay without lag.
         Parry Sound: Add cool sound effects when parrying, choose from 7 types or input custom IDs.
         World Filters: Change BladeBalls vibe, from fog, saturation, to hue shift.
         Night Mode: Play in a dark atmosphere, super aesthetic!
         Custom Sky: Swap the sky with 18 options, from Default to DaBaby, lol.
         Open Crates: Automatically open Sword & Explosion Crates, get rare items!
         Strafe & Speed: Agile movements, adjust speed to your preference.
         Fly: Freely fly in the arena, supports mobile & PC with joystick/WASD!
         Personnel Detector: Detect mods from afar, plus Auto Leave for safety.
         Gravity Control: Play with gravity, adjust strength for more fun!
         Player Cosmetics: Use Headless or Korblox, make your character stand out.
         FOV Camera: Adjust field of view, for wider or more focused vision.
         Ability Vulnerability: Add strategy with modes like Quad Jump or Quasar.
         AI Play (V1 & V2): Let AI play for you, from BallChaser to AggressiveHunter!
         Auto Farm Orbit: Farm coins automatically with cool movements like Helix or Figure8.
         Config Save/Load: Save all settings, no need to reset every time you play.
         Emotes: Flex custom animations like Dance or Floss while dominating!
         Auto Requeue: Auto-join Duels, Ranked, or LTM queues for non-stop grinding!

         And Other All features work (but, you know, fully Script). Heartbeat-based, CMIIW 
        Check out new features in other tabs!
    ]],
    Image = "rbxassetid://124408123120792",
    ImageSize = 45
})

Tabs.Home:Button({
    Title = "Dialog Of Owner",
    Callback = function()
        Window:Dialog({
            Title = "[VicoX] Big BladeBall Update",
            Content = "V.Exclusive Version",
            Icon = "bird",
            Buttons = {
                {
                    Title = "[Rudert]\n ... month after month.",
                    Icon = "bird",
                    Variant = "Tertiary",
                    Callback = function()
                        print("i was waiting for so long")
                    end,
                },
                {
                    Title = "[E4X]\n -..",
                    Icon = "bird",
                    Variant = "Tertiary",
                    Callback = function()
                        print("hm")
                    end,
                },
                {
                    Title = "[Fx]\n -",
                    Icon = "bird",
                    Variant = "Secondary",
                    Callback = function()
                        print("mhm")
                    end,
                },
                {
                    Title = "[GhX]\n -.",
                    Icon = "bird",
                    Variant = "Secondary",
                    Callback = function()
                        print("mhm")
                    end,
                },
                {
                    Title = "[Nurysium]\nNot Respond",
                    Icon = "bird",
                    Variant = "Primary",
                    Callback = function() 
                        print(":[]")
                    end,
                }
            }
        })
    end,
})

Tabs.Special:Paragraph({
    Title = "Special Function Ahh trash ",
    Desc = "Welp yeah here it is",
    Image = "rbxassetid://124408123120792",
    ImageSize = 42,    
})

Tabs.Special:Section({ Title = "Plushie" })

Tabs.Special:Toggle({
    Title = "Plushie",
    Icon = "repeat",
    Value = true,
    Callback = function(value)
        Config.plushie_enabled = value
        WindUI:Notify({
            Title = "Plushie Enabled",
            Content = value and "Plushie enabled" or "Plushie disabled",
            Duration = 0.5,
            Icon = "repeat"
        })
    end
})

Tabs.Special:Divider()

Tabs.Special:Dropdown({
	Title = "Plushie Select",
	Values = {"Miku", "SpongeBob", "Patrick", "Sonic", "Shion", "Kaito", "Reimu", "Len", "Bear", "Frieren"},
	Value = "Miku",
	Callback = function(option)
            Config.plushie_type = option
	    WindUI:Notify({
            Title = "Plushie Selected",
            Content = "Plushie Change to" .. option,
            Duration = 0.5,
            Icon = "rotate-cw"
        })
    end
})

Tabs.Special:Section({ Title = "Skin Changer" })

Tabs.Special:Toggle({
    Title = "Skin Changer",
    Icon = "sword",
    Value = false,
    Callback = function(value)
        getgenv().skinChanger = value
        Config.skinChanger = value
        if value then
            getgenv().updateSword()
            WindUI:Notify({
                Title = "Skin Changer",
                Content = "Skin Changer enabled",
                Duration = 0.5,
                Icon = "sword"
            })
        else
            WindUI:Notify({
                Title = "Skin Changer",
                Content = "Skin Changer disabled",
                Duration = 0.5,
                Icon = "sword"
            })
        end
    end
})

Tabs.Special:Divider()

Tabs.Special:Input({
    Title = "Skin Name Sword (Case Sensitive)",
    Icon = "edit",
    Placeholder = "Enter Sword Skin Name...",
    Value = "",
    Callback = function(input)
        getgenv().swordModel = input
        getgenv().swordAnimations = input
        getgenv().swordFX = input
        Config.swordModel = input
        Config.swordAnimations = input
        Config.swordFX = input
        if getgenv().skinChanger then
            getgenv().updateSword()
            WindUI:Notify({
                Title = "Skin Changer",
                Content = "Set sword skin to " .. input,
                Duration = 0.5,
                Icon = "sword"
            })
        else
            WindUI:Notify({
                Title = "Skin Changer",
                Content = "Enable Skin Changer to apply " .. input,
                Duration = 0.5,
                Icon = "alert-triangle"
            })
        end
    end
})

Tabs.Special:Section({ Title = "Music" })

Tabs.Special:Toggle({
    Title = "Background Music",
    Icon = "music",
    Value = false,
    Callback = function(value)
        if value then
            playSound()
        else
            currentSound:Stop()
            WindUI:Notify({
                Title = "Background Music",
                Content = "Music stopped",
                Duration = 0.5,
                Icon = "music"
            })
        end
    end
})

Tabs.Special:Divider()

-- Dropdown Pilih Lagu
Tabs.Special:Dropdown({
    Title = "Select Song",
    Icon = "list-music",
    Values = {
        "back it up", "Sweep", "Bounce", "Everybody Wants To Rule The World",
        "Missing Money", "Sour Grapes", "Erwachen", "Grasp the Light",
        "Beyond the Shadows", "Rise to the Horizon", "Echoes of the Candy Kingdom",
        "Speed", "Lo-fi Chill A", "Lo-fi Ambient", "Tears in the Rain"
    },
    Value = "back it up",
    Callback = function(value)
        selectedSound = value
        if currentSound.Playing then
            playSound()
        else
            WindUI:Notify({
                Title = "Select Song",
                Content = "Selected " .. value,
                Duration = 5,
                Icon = "list-music"
            })
        end
    end
})

-- Checkbox Loop
Tabs.Special:Toggle({
    Title = "Loop Song",
    Icon = "repeat",
    Value = false,
    Callback = function(value)
        currentSound.Looped = value
        WindUI:Notify({
            Title = "Loop Song",
            Content = value and "Loop enabled" or "Loop disabled",
            Duration = 0.5,
            Icon = "repeat"
        })
    end
})

-- Slider Volume
Tabs.Special:Slider({
    Title = "Volume",
    Icon = "volume-high",   
    Value = { Min = 1, Max = 5, Default = 3 },
    Callback = function(value)
        currentSound.Volume = value
        WindUI:Notify({
            Title = "Volume",
            Content = "Volume set to " .. string.format("%.1f", value),
            Duration = 0.5,
            Icon = "volume-high"
        })
    end
})

Tabs.Blatant:Paragraph({
    Title = "GAME: BLADEBALL",
    Desc = "Dominate Em! ",
    Image = "rbxassetid://124408123120792",
    ImageSize = 42,
    Thumbnail = "https://tr.rbxcdn.com/180DAY-59af3523ad8898216dbe1043788837bf/768/432/Image/Webp/noFilter",
    ThumbnailSize = 120,
    Buttons = {
        {
            Title = "Reset Parry (If get bug)",
            Variant = "Primary",
            Callback = function() AutoParry.reset() end,
            Icon = "refresh-ccw",
        }
    }
})

Tabs.Blatant:Section({ Title = "Main Auto Parry/Spam" })

Tabs.Blatant:Toggle({
    Title = "Auto Parry",
    Icon = "swords",
    Value = Config.auto_parry,    
    Callback = function(state)
        Config.auto_parry = state
        WindUI:Notify({
            Title = "Auto Parry",
            Content = "Auto Parry " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "swords"
        })
    end
})

Tabs.Blatant:Toggle({
    Title = "Triggerbot Helper",
    Desc = "Trigger Bot And Check Respond Within Parry, Fast Check With Respond Range / Accuracy BOT, Please Turn On With AutoParry", 
    Icon = "sword",
    Value = Config.triggerbot,
    Callback = function(state)
        Config.triggerbot = state
        WindUI:Notify({
            Title = "Triggerbot",
            Content = "Triggerbot " .. (state and "enabled" or "disabled"),
            Duration = 3,
            Icon = "sword"
        })

        if state then
            if not ConnectionsManager["triggerbot"] then
                ConnectionsManager["triggerbot"] = RunService.PostSimulation:Connect(function()
                    local character = LocalPlayer.Character
                    if not character or not character:FindFirstChild("HumanoidRootPart") or character.Parent == workspace.Dead then
                        return
                    end

                    local ball = AutoParry.get_ball()
                    if not ball or not AutoParry.ball.ball_entity then
                        return
                    end

                    local ball_properties = AutoParry.ball.properties
                    local singularityCape = character.PrimaryPart:FindFirstChild('SingularityCape')
                    if singularityCape then
                        return
                    end

                    local ping_threshold = math.clamp(Player.Entity.properties.ping / 10, 15, 20)
                    local parry_range = (ping_threshold + ball_properties.speed) * 2 / math.pi

                    if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name then
                        if ball_properties.distance > parry_range then
                            return
                        end
                        
                        ball_properties.is_curved = AutoParry.is_curved()
                        ball_properties.is_curveds = AutoParry.is_curveds()
                        if ball_properties.is_curved or ball_properties.is_curveds then
                            return
                        end

                        if (tick() - ball_properties.last_hit) < (1 - math.clamp(ping_threshold / 100, 0.1, 0.7)) then
                            return
                        end

                        task.spawn(function() AutoParry:PerformParry() end)
                        ball_properties.last_hit = tick()
                    end
                end)
            end
        else
            if ConnectionsManager["triggerbot"] then
                ConnectionsManager["triggerbot"]:Disconnect()
                ConnectionsManager["triggerbot"] = nil
            end
        end
    end
})

Tabs.Blatant:Toggle({
    Title = "Auto Ability",
    Value = false,
    Callback = function(state)
        AutoAbility.enabled = state
        WindUI:Notify({
            Title = "Auto Ability",
            Content = "Auto Ability " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
        })
    end
})



Tabs.Blatant:Divider()

Tabs.Blatant:Slider({
     Title = "Spam Speed",    
     Value = { Min = 1, Max = 100, Default = 2 },
     Callback = function(value)
        getgenv().speeddo = value
        WindUI:Notify({
            Title = "Acuity",
            Content = "Acuity set to " .. value,
            Duration = 0.5,
            Icon = "sliders-horizontal"
        })
    end
})

Tabs.Blatant:Dropdown({
	Title = "Auto Parry Mode (Blatant Best)",
	Values = {"Legit", "Blatant"},
	Value = "Blatant",
	Callback = function(option)
            parry_mode = option
	    WindUI:Notify({
            Title = "Auto Parry Mode",
            Content = "Parry Mode Change to" .. option,
            Duration = 0.5,
            Icon = "rotate-cw"
        })
    end
})

Tabs.Blatant:Dropdown({
    Title = "Parry Method Fire (Please use Hook Methode! dont use Getgc because it pactched)",
    Values = { "getgc", "Hook" },
    Value = "Hook",
    Callback = function(option)
        SelectedParryMethod = option
        WindUI:Notify({
            Title = "Parry Methode",
            Content = "Parry Methode Change to" .. option,
            Duration = 0.5,
            Icon = "rotate-cw"
        })
    end
})

Tabs.Blatant:Toggle({
    Title = "Manual Spam",
    Icon = "swords",
    Value = false,
    Callback = function(state)
        Config.manual_spam = state
        if state then
            ManualSpam() 
        else
            if ManualSpamGui then
                ManualSpam()
            end
        end
        WindUI:Notify({
            Title = "Manual Spam",
            Content = "Manual Spam " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "swords"
        })
    end
})

Tabs.Blatant:Section({ Title = "Rotation Player" })

Tabs.Blatant:Toggle({
    Title = "Rotation",
    Icon = "rotate-cw",
    Value = false,    
    Callback = function(state)
        Config.auto_parry_rotation = state
        WindUI:Notify({
            Title = "Rotation",
            Content = "Rotation " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "rotate-cw"
        })
    end
})

Tabs.Blatant:Divider()

Tabs.Blatant:Slider({
    Title = "Acuity",
    Icon = "sliders-horizontal",
    Value = { Min = 0, Max = 100, Default = 5 },
    Callback = function(value)
        Config.auto_parry_rotation_acuity = value
        WindUI:Notify({
            Title = "Acuity",
            Content = "Acuity set to " .. value,
            Duration = 0.5,
            Icon = "sliders-horizontal"
        })
    end
})

Tabs.Blatant:Section({ Title = "Curve Parry" })

Tabs.Blatant:Dropdown({
    Title = "Curve Method",
    Icon = "chevrons-up-down",
    Values = { "Linear", "Backwards", "Random", "Accelerated", "Right", "Left", "Up", "Down", "Normal", "FollowCamera", "Forward", "Circular" },
    Value = "Normal",
    Callback = function(option)
        Config.curve_method = option
        WindUI:Notify({
            Title = "Curve Method",
            Content = "Curve Method set to " .. option,
            Duration = 0.5,
            Icon = "chevrons-up-down"
        })
    end
})

Tabs.Blatant:Section({ Title = "No Slow Mode" })

Tabs.Blatant:Toggle({
    Title = "No Slow",
    Icon = "zap",
    Value = false,
    Callback = function(state)
        Config.no_slow = state
        WindUI:Notify({
            Title = "No Slow",
            Content = "No Slow " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "zap"
        })
    end
})

Tabs.Visuals:Paragraph({
    Title = "Visuals",
    Desc = "Customize your Blade Ball experience",
    Image = "rbxassetid://129260712070622",
    ImageSize = 42,
    Color = "Red"
})

Tabs.Visuals:Section({ Title = "Effect" })

Tabs.Visuals:Toggle({
    Title = "Self Effect",
    Icon = "sparkles",
    Value = true,
    Callback = function(state)
        Config.self_effect = state        
        WindUI:Notify({
            Title = "Self Effect",
            Content = "Self Effect " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "sparkles"
        })

        if state then
            if not ConnectionsManager["self_effect"] then
                ConnectionsManager["self_effect"] = RunService.Heartbeat:Connect(function()
                    if not Config.self_effect then
                        return
                    end

                    local local_player = LocalPlayer
                    if not local_player or not local_player.Character then
                        return
                    end

                    local primaryPart = local_player.Character:FindFirstChild("HumanoidRootPart")
                    if not primaryPart then
                        return
                    end

                    local selectedEffect = Config.self_effect_selected or "Magic Circle"
                    local effectMapping = {
                    ["Magic Circle"] = "rbxassetid://17519530107",
                    ["Smokey"] = "rbxassetid://9264792205"
                   }

                    local selectedEffectID = effectMapping[selectedEffect]
                    if not selectedEffectID then
                        WindUI:Notify({
                            Title = "Self Effect",
                            Content = "Invalid effect selected: " .. tostring(selectedEffect),
                            Duration = 7,
                            Icon = "alert-triangle"
                        })
                        return
                    end

                    local existingEffect = primaryPart:FindFirstChild("nurysium_efx")
                    if existingEffect then
                        return
                    end

                    local success, effect = pcall(function()
                        return game:GetObjects(selectedEffectID)[1]
                    end)

                    if not success or not effect then
                        WindUI:Notify({
                            Title = "Self Effect",
                            Content = "Failed to load effect: " .. tostring(selectedEffect),
                            Duration = 7,
                            Icon = "alert-octagon"
                        })
                        return
                    end

                    effect.Name = "nurysium_efx"
                    effect.Parent = primaryPart
                end)
            end
        else
            if ConnectionsManager["self_effect"] then
                ConnectionsManager["self_effect"]:Disconnect()
                ConnectionsManager["self_effect"] = nil
            end

            local local_player = LocalPlayer
            if local_player and local_player.Character then
                local primaryPart = local_player.Character:FindFirstChild("HumanoidRootPart")
                if primaryPart then
                    local existingEffect = primaryPart:FindFirstChild("nurysium_efx")
                    if existingEffect then
                        existingEffect:Destroy()
                    end
                end
            end
        end
    end
})

Tabs.Visuals:Dropdown({    
    Title = "Select Self Effect",
    Values = {
        "Magic Circle",
        "Smokey"       
    },
    Value = "Magic Circle",
    Callback = function(value)
        Config.self_effect_selected = value
        WindUI:Notify({
            Title = "Self Effect",
            Content = "Selected effect: " .. value,
            Duration = 0.5,
            Icon = "sparkles"
        })

        if Config.self_effect_selected then
            local local_player = LocalPlayer
            if local_player and local_player.Character then
                local primaryPart = local_player.Character:FindFirstChild("HumanoidRootPart")
                if primaryPart then
                    local existingEffect = primaryPart:FindFirstChild("nurysium_efx")
                    if existingEffect then
                        existingEffect:Destroy()
                    end
                end
            end

            if Config.self_effect then
                local effectMapping = {
                    ["Magic Circle"] = "rbxassetid://17519530107",
                    ["Smokey"] = "rbxassetid://9264792205"                    
                }

                local selectedEffectID = effectMapping[selected]
                if not selectedEffectID then
                    WindUI:Notify({
                        Title = "Self Effect",
                        Content = "Invalid effect selected: " .. tostring(selected),
                        Duration = 7,
                        Icon = "alert-triangle"
                    })
                    return
                end

                local success, effect = pcall(function()
                    return game:GetObjects(selectedEffectID)[1]
                end)

                if not success or not effect then
                    WindUI:Notify({
                        Title = "Self Effect",
                        Content = "Failed to load effect: " .. tostring(selected) .. ". Using Magic Circle.",
                        Duration = 7,
                        Icon = "alert-octagon"
                    })
                    Config.self_effect_selected = "Magic Circle"
                    selectedEffectID = effectMapping["Magic Circle"]
                    success, effect = pcall(function()
                        return game:GetObjects(selectedEffectID)[1]
                    end)
                    if not success or not effect then
                        return
                    end
                end

                if local_player and local_player.Character then
                    local primaryPart = local_player.Character:FindFirstChild("HumanoidRootPart")
                    if primaryPart then
                        if effect:IsA("Decal") or effect:IsA("KeyframeSequence") then
                            WindUI:Notify({
                                Title = "Self Effect",
                                Content = "Unsupported effect type: " .. effect.ClassName .. " for " .. selected,
                                Duration = 7,
                                Icon = "alert-triangle"
                            })
                            return
                        elseif effect:IsA("Model") then
                            local primary = effect.PrimaryPart or effect:GetChildren()[1]
                            if primary and primary:IsA("BasePart") then
                                effect.Name = "nurysium_efx"
                                primary.Parent = primaryPart
                                primary.CFrame = primaryPart.CFrame
                                for _, child in pairs(effect:GetChildren()) do
                                    if child:IsA("ParticleEmitter") then
                                        child.Enabled = true
                                        child.Rate = math.max(child.Rate, 20)
                                        child.Transparency = NumberSequence.new(0)
                                        child.Size = NumberSequence.new(0.5, 1) -- Adjust size for Glow dust Snow
                                    end
                                end
                            else
                                WindUI:Notify({
                                    Title = "Self Effect",
                                    Content = "Model effect " .. selected .. " has no valid parts.",
                                    Duration = 7,
                                    Icon = "alert-triangle"
                                })
                                return
                            end
                        elseif effect:IsA("ParticleEmitter") then
                            effect.Name = "nurysium_efx"
                            effect.Enabled = true
                            effect.Rate = math.max(effect.Rate, 20)
                            effect.Transparency = NumberSequence.new(0)
                            effect.Size = NumberSequence.new(0.5, 1) -- Adjust size for Glow dust Snow
                            effect.Parent = primaryPart
                        else
                            WindUI:Notify({
                                Title = "Self Effect",
                                Content = "Unsupported effect type: " .. effect.ClassName .. " for " .. selected,
                                Duration = 7,
                                Icon = "alert-triangle"
                            })
                            return
                        end
                    end
                end
            end
        end
    end
})

Tabs.Visuals:Toggle({
    Title = "Kill Effect",
    Icon = "bell",
    Value = false,
    Callback = function(state)
        Config.kill_effect = state
        WindUI:Notify({
            Title = "Kill Effect",
            Content = "Kill Effect " .. (state and "enabled" or "disabled"),
            Duration = 5,
            Icon = "bell"
        })
    end
})

Tabs.Visuals:Slider({
    Title = "Bell Scale",
    Icon = "sliders-horizontal",
    Value = { Min = 1, Max = 5, Default = 1 },
    Callback = function(value)
        Config.kill_effect_scale = value
        WindUI:Notify({
            Title = "Bell Scale",
            Content = "Bell Scale set to " .. value .. "x",
            Duration = 5,
            Icon = "sliders-horizontal"
        })
    end
})

Tabs.Visuals:Dropdown({
    Title = "Kill Effect Animation",
    Icon = "chevrons-up-down",
    Values = {"Linear", "Spiral", "Pulse"},
    Value = "Spiral",
    Multi = false,
    Callback = function(selected)
        Config.kill_effect_animation = selected
        WindUI:Notify({
            Title = "Kill Effect Animation",
            Content = "Animation set to " .. selected,
            Duration = 5,
            Icon = "chevrons-up-down"
        })
    end
})

Tabs.Visuals:Section({ Title = "Monitor Ball Visuals" })

-- Add Visualizer Toggle to Visuals Tab
Tabs.Visuals:Toggle({
    Title = "Visualizer Monitor (Ball)",
    Icon = "eye",
    Value = true, -- Keep your default value
    Callback = function(state)
        Config.visualize = state
        WindUI:Notify({
            Title = "Visualizer",
            Content = "Visualizer " .. (state and "enabled" or "disabled"),
            Duration = 5,
            Icon = "eye"
        })

        if state then
            if not ConnectionsManager["visualizer"] then
                task.defer(function()
                    -- Create the visualizer part
                    local visualizePart = Instance.new("Part", workspace)
                    visualizePart.Name = "VisualizePart"
                    visualizePart.Material = Enum.Material.ForceField
                    visualizePart.CanCollide = false
                    visualizePart.Shape = Enum.PartType.Ball
                    visualizePart.Transparency = 0
                    visualizePart.Size = Vector3.new(2, 2, 2) -- Increased default size
                    visualizePart.Color = Color3.fromRGB(0, 255, 0) -- Start with green (no lag)

                    -- Store the part in a table to access it in the connection
                    local visualizerData = { part = visualizePart }

                    -- Set up RenderStepped connection
                    ConnectionsManager["visualizer"] = RunService.RenderStepped:Connect(function()
                        if not visualizerData.part then
                            ConnectionsManager["visualizer"]:Disconnect()
                            ConnectionsManager["visualizer"] = nil
                            return
                        end

                        local ball = AutoParry.get_ball() -- Use your get_ball function
                        if not ball then
                            visualizerData.part.Transparency = 1
                            return
                        end

                        local ballPosition = ball.Position
                        local player = LocalPlayer.Character
                        if not player or not player:FindFirstChild("HumanoidRootPart") then
                            visualizerData.part.Transparency = 1
                            return
                        end

                        -- Calculate distance for size scaling
                        local playerPosition = player.HumanoidRootPart.Position
                        local distance = (ballPosition - playerPosition).Magnitude
                        local maxDistance = 50 -- Maximum distance for size scaling
                        local minSize = 2 -- Increased minimum size
                        local maxSize = 7 -- Increased maximum size
                        local size = maxSize - (maxSize - minSize) * (distance / maxDistance)
                        size = math.clamp(size, minSize, maxSize)

                        -- Calculate lag (distance between visualizer and actual ball position)
                        local lagDistance = (visualizerData.part.Position - ballPosition).Magnitude

                        -- Set color based on lag
                        if lagDistance < 0.5 then
                            visualizerData.part.Color = Color3.fromRGB(0, 255, 0) -- Green: No lag
                        elseif lagDistance < 2 then
                            visualizerData.part.Color = Color3.fromRGB(255, 255, 0) -- Yellow: Moderate lag
                        else
                            visualizerData.part.Color = Color3.fromRGB(255, 0, 0) -- Red: High lag
                        end

                        -- Update part properties
                        visualizerData.part.Transparency = 0
                        visualizerData.part.Position = ballPosition
                        visualizerData.part.Size = Vector3.new(size, size, size)
                    end)
                end)
            end
        else
            -- Clean up when disabled
            if ConnectionsManager["visualizer"] then
                ConnectionsManager["visualizer"]:Disconnect()
                ConnectionsManager["visualizer"] = nil
            end
            -- Destroy the part if it exists
            local existingPart = workspace:FindFirstChild("VisualizePart")
            if existingPart then
                existingPart:Destroy()
            end
        end
    end
})

Tabs.Visuals:Section({ Title = "Visuals Rings 3D" })

Tabs.Visuals:Toggle({
    Title = "Visual Ring",   
    Value = false,
    Callback = function(state)
        Config.visual_ring = state
        WindUI:Notify({
            Title = "Visual Ring",
            Content = "Visual Ring " .. (state and "enabled" or "disabled"),
            Duration = 5            
        })
    end
})

Tabs.Visuals:Section({ Title = "Visuals Effect" })

Tabs.Visuals:Toggle({
    Title = "Visual ESP V1",
    Value = true,
    Callback = function(state)
        Config.visuals_enabled = state
        WindUI:Notify({
            Title = "Visual Effects",
            Content = "Visual Effects " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
        })
    end
})

Tabs.Visuals:Section({ Title = "Indicator" })

Tabs.Visuals:Toggle({
    Title = "Ball Direction Indicator",
    Value = true,
    Callback = function(state)
        getgenv().BallDirectionIndicator = state
        ScreenGui.Enabled = state
        WindUI:Notify({
            Title = "Ball Direction Indicator",
            Content = "Indicator " .. (state and "ON" or "OFF"),
            Duration = 0.5,
        })
    end
})

Tabs.Visuals:Section({ Title = "Visualizer Range" })

Tabs.Visuals:Toggle({
    Title = "Visualizer V2",
    Icon = "rotate-cw",
    Value = false,    
    Callback = function(state)
        Config.visualize_Enabled = state
        WindUI:Notify({
            Title = "Visualizer Mode",
            Content = "Visualizer Mode to" .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "rotate-cw"
        })
    end
})

Tabs.Visuals:Section({ Title = "Camera Lock" })

Tabs.Visuals:Toggle({
    Title = "Camera Lock To Ball",
    Value = false,
    Callback = function(state)
        cameraLocked = state
        if state then
            ConnectionsManager["CameraLock"] = RunService.RenderStepped:Connect(function()
                local ball = AutoParry.ball.ball_entity
                local character = LocalPlayer.Character
                local primaryPart = character and (character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart)
                
                if ball and ball:IsDescendantOf(Workspace) and primaryPart then
                    local ballPos = ball.Position
                    local playerPos = primaryPart.Position
                    local cameraPos, lookAtPos

                    if cameraViewMode == "ThirdPerson" then
                        cameraPos = playerPos + Vector3.new(0, 5, 10)
                        lookAtPos = ballPos
                    elseif cameraViewMode == "FirstPerson" then
                        cameraPos = playerPos + Vector3.new(0, 2, 0)
                        lookAtPos = ballPos
                    elseif cameraViewMode == "TopDown" then
                        cameraPos = ballPos + Vector3.new(0, 20, 0)
                        lookAtPos = ballPos
                    elseif cameraViewMode == "SideView" then
                        local offset = (ballPos - playerPos).Unit:Cross(Vector3.new(0, 1, 0)) * 15
                        cameraPos = ballPos + offset + Vector3.new(0, 5, 0)
                        lookAtPos = ballPos
                    end

                    Camera.CFrame = CFrame.new(cameraPos, lookAtPos)
                end
            end)
        else
            if ConnectionsManager["CameraLock"] then
                ConnectionsManager["CameraLock"]:Disconnect()
                ConnectionsManager["CameraLock"] = nil
            end
            Camera.CameraType = Enum.CameraType.Custom
        end
    end
})

Tabs.Visuals:Divider()

Tabs.Visuals:Dropdown({
    Title = "Camera View Mode",
    Values = {"ThirdPerson", "FirstPerson", "TopDown", "SideView"},
    Value = "ThirdPerson",
    Multi = false,
    Callback = function(value)
        cameraViewMode = value
    end
})

Tabs.Visuals:Section({ Title = "Text Debug" })

Tabs.Visuals:Toggle({
    Title = "Ball Text Debug",   
    Value = Config.ball_text_enabled,
    Callback = function(state)
        Config.ball_text_enabled = state
        if updateBillboardText then
            updateBillboardText()
        else
            warn("updateBillboardText is nil in Ball Text toggle")
        end
        WindUI:Notify({
            Title = "Ball Text",
            Content = "Ball Text " .. (state and "enabled" or "disabled"),
            Duration = 0.5,          
        })
    end
})

Tabs.Visuals:Toggle({
    Title = "Player Text Debug",   
    Value = Config.player_text_enabled,
    Callback = function(state)
        Config.player_text_enabled = state
        if updateBillboardText then
            updateBillboardText()
        else
            warn("updateBillboardText is nil in Player Text toggle")
        end
        WindUI:Notify({
            Title = "Player Text",
            Content = "Player Text " .. (state and "enabled" or "disabled"),
            Duration = 0.5,          
        })
    end
})

Tabs.Visuals:Section({ Title = "Trails", Icon = "sparkles" })

Tabs.Visuals:Toggle({
    Title = "Ball Trail",
    Icon = "sparkles",
    Value = false,
    Callback = function(state)
        Config.ball_trail_enabled = state
        if state or Config.player_trail_enabled then
            task.spawn(StartTrailUpdate)
        else
            task.spawn(StopTrailUpdate)
        end
        WindUI:Notify({
            Title = "Ball Trail",
            Content = "Ball Trail " .. (state and "enabled" or "disabled"),
            Duration = 5,
            Icon = "sparkles"
        })
    end
})

Tabs.Visuals:Colorpicker({
    Title = "Ball Trail Color",
    Icon = "palette",
    Value = Color3.fromRGB(255, 0, 0),
    Callback = function(color)
        Config.ball_trail_color = color
        WindUI:Notify({
            Title = "Ball Trail Color",
            Content = "Color updated",
            Duration = 5,
            Icon = "palette"
        })
    end
})

Tabs.Visuals:Toggle({
    Title = "Player Trail",
    Icon = "sparkles",
    Value = false,
    Callback = function(state)
        Config.player_trail_enabled = state
        if state or Config.ball_trail_enabled then
            task.spawn(StartTrailUpdate)
        else
            task.spawn(StopTrailUpdate)
        end
        WindUI:Notify({
            Title = "Player Trail",
            Content = "Player Trail " .. (state and "enabled" or "disabled"),
            Duration = 5,
            Icon = "sparkles"
        })
    end
})

Tabs.Visuals:Colorpicker({
    Title = "Player Trail Color",
    Icon = "palette",
    Value = Color3.fromRGB(0, 255, 255),
    Callback = function(color)
        Config.player_trail_color = color
        WindUI:Notify({
            Title = "Player Trail Color",
            Content = "Color updated",
            Duration = 5,
            Icon = "palette"
        })
    end
})

Tabs.Visuals:Divider()

Tabs.Visuals:Toggle({
    Title = "Trail Particles",
    Icon = "sparkle",
    Value = false,
    Callback = function(state)
        Config.trail_particle_enabled = state
        WindUI:Notify({
            Title = "Trail Particles",
            Content = "Trail Particles " .. (state and "enabled" or "disabled"),
            Duration = 5,
            Icon = "sparkle"
        })
    end
})

Tabs.Visuals:Slider({
    Title = "Particle Rate",
    Icon = "sliders-horizontal",
    Value = { Min = 5, Max = 50, Default = 10 },
    Callback = function(value)
        Config.trail_particle_rate = value
        WindUI:Notify({
            Title = "Particle Rate",
            Content = "Particle Rate set to " .. value,
            Duration = 5,
            Icon = "sliders-horizontal"
        })
    end
})

Tabs.Visuals:Dropdown({
    Title = "Trail Animation Type",
    Icon = "chevrons-up-down",
    Values = {"Static", "Pulse", "Flicker"},
    Value = "Pulse",
    Multi = false,
    Callback = function(selected)
        Config.trail_animation_type = selected
        WindUI:Notify({
            Title = "Trail Animation",
            Content = "Animation set to " .. selected,
            Duration = 5,
            Icon = "chevrons-up-down"
        })
    end
})

Tabs.Visuals:Dropdown({
    Title = "Trail Texture",
    Icon = "image",
    Values = {"None", "Spark", "Flame"},
    Value = "None",
    Multi = false,
    Callback = function(selected)
        Config.trail_texture = selected
        WindUI:Notify({
            Title = "Trail Texture",
            Content = "Texture set to " .. selected,
            Duration = 5,
            Icon = "image"
        })
    end
})

Tabs.Visuals:Section({ Title = "No Rendering" })

-- Visuals Tab
Tabs.Visuals:Toggle({
    Title = "No Render",
    Icon = "eye-off",
    Value = false,
    Callback = function(state)
        Config.no_render = state
        WindUI:Notify({
            Title = "No Render",
            Content = "No Render " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "eye-off"
        })
    end
})

Tabs.Visuals:Toggle({
    Title = "Smart No Render",
    Icon = "brain",
    Value = false,
    Callback = function(state)
        Config.smart_no_render = state
        WindUI:Notify({
            Title = "Smart No Render",
            Content = "Smart No Render " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "brain"
        })
    end
})

Tabs.Visuals:Section({ Title = "Sound Block" })

Tabs.Visuals:Toggle({
    Title = "Parry Sound",
    Icon = "music",
    Value = false,
    Callback = function(state)
        Config.sound_effect_enabled = state
        WindUI:Notify({
            Title = "Parry Sound",
            Content = "Parry Sound " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "music"
        })
    end
})

Tabs.Visuals:Divider()

Tabs.Visuals:Dropdown({
    Title = "Sound Type",
    Icon = "volume-2",
    Values = {'DC_15X','Neverlose','Minecraft','MinecraftHit2','TeamfortressBonk','TeamfortressBell',"Custom", "Medal", 
        "Fatality", 
        "Skeet",
        "Switches",
        "Rust Headshot", 
        "Neverlose Sound", 
        "Bubble", 
        "Laser", 
        "Steve", 
        "Call of Duty", 
        "Bat", 
        "TF2 Critical", 
        "Saber", 
        "Bameware"},  
    Value = "DC_15X",
    Callback = function(Value)
        sound_effect_type = Value
        WindUI:Notify({
            Title = "Sound Type",
            Content = "Sound Type set to " .. Value,
            Duration = 0.5,
            Icon = "volume-2"
        })
    end
})

Tabs.Visuals:Input({
    Title = "Custom Sound ID",
    Icon = "audio-lines",
    Placeholder = "Enter sound id",
    Callback = function(text)
        CustomId = text
        WindUI:Notify({
            Title = "Custom Sound",
            Content = "Custom Sound ID set to " .. text,
            Duration = 0.5,
            Icon = "audio-lines"
        })
    end
})

Tabs.Worlds:Paragraph({
    Title = "Worlds Enchance",
    Desc = "Change your World baaby!",    
    Color = "Green"
})

Tabs.Worlds:Section({ Title = "Advanced Worlds (Deleted Better Perform)" })

Tabs.Worlds:Section({ Title = "Night and Monday" })

Tabs.Worlds:Toggle({
    Title = "Night Mode",
    Icon = "moon",
    Value = false,
    Callback = function(state)
        Config.night_mode = state
        WindUI:Notify({
            Title = "Night Mode",
            Content = "Night Mode " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "moon"
        })
    end
})

Tabs.Worlds:Section({ Title = "Sky" })

Tabs.Worlds:Toggle({
    Title = "Custom Sky",
    Icon = "cloud",
    Value = false,
    Callback = function(value)
        Config.custom_sky = value
        local Lighting = game:GetService("Lighting")
        local Sky = Lighting:FindFirstChildOfClass("Sky")
        if value then
            if not Sky then
                Sky = Instance.new("Sky", Lighting)
            end
            -- Apply the last selected skybox
            local selectedOption = getgenv().Config.custom_sky_selector or "Default"
            local data = skyboxData[selectedOption]
            if data then
                local skyFaces = {"SkyboxBk", "SkyboxDn", "SkyboxFt", "SkyboxLf", "SkyboxRt", "SkyboxUp"}
                for index, face in ipairs(skyFaces) do
                    Sky[face] = "rbxassetid://" .. data[index]
                end
                Lighting.GlobalShadows = false
            end
        else
            if Sky then
                Sky:Destroy()
            end
            Lighting.GlobalShadows = true
        end
        WindUI:Notify({
            Title = "Custom Sky",
            Content = "Custom Sky " .. (value and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "cloud"
        })
    end
})

Tabs.Worlds:Divider()

Tabs.Worlds:Dropdown({
    Title = "Select Sky",
    Icon = "cloud-drizzle",
    Values = {
        "Default", "Vaporwave", "Redshift", "Desert", "DaBaby", "Minecraft",
        "SpongeBob", "Skibidi", "Blaze", "Pussy Cat", "Among Us", "Space Wave",
        "Space Wave2", "Turquoise Wave", "Dark Night", "Bright Pink",
        "White Galaxy", "Blue Galaxy"
    },
    Value = "Default",
    Callback = function(selectedOption)
        Config.custom_sky_selector = selectedOption
        if not Config.custom_sky then
            WindUI:Notify({
                Title = "Custom Sky",
                Content = "Enable Custom Sky to apply " .. selectedOption,
                Duration = 0.5,
                Icon = "cloud"
            })
            return
        end
        local data = skyboxData[selectedOption]
        if not data then
            WindUI:Notify({
                Title = "Skybox Error",
                Content = "Sky option not found: " .. tostring(selectedOption),
                Duration = 0.5,
                Icon = "alert-triangle"
            })
            return
        end
        local Lighting = game:GetService("Lighting")
        local Sky = Lighting:FindFirstChildOfClass("Sky") or Instance.new("Sky", Lighting)
        local skyFaces = {"SkyboxBk", "SkyboxDn", "SkyboxFt", "SkyboxLf", "SkyboxRt", "SkyboxUp"}
        local success, err = pcall(function()
            for index, face in ipairs(skyFaces) do
                Sky[face] = "rbxassetid://" .. data[index]
            end
            Lighting.GlobalShadows = false
        end)
        if not success then
            WindUI:Notify({
                Title = "Skybox Error",
                Content = "Failed to load " .. selectedOption .. " skybox: " .. tostring(err),
                Duration = 0.5,
                Icon = "alert-triangle"
            })
            return
        end
        WindUI:Notify({
            Title = "Select Sky",
            Content = "Skybox set to " .. selectedOption,
            Duration = 0.5,
            Icon = "cloud-drizzle"
        })
    end
})

Tabs.Misc:Paragraph({
    Title = "Utility Features",
    Desc = "tools to enhance your Blade Ball gameplay.",
    Image = "rbxassetid://129260712070622",
    ImageSize = 42,
    Color = "Blue"
})

Tabs.Misc:Section({ Title = "Ping Booster Select" })

Tabs.Misc:Button({
    Title = "Load Ping Booster",
    Icon = "network-wired",
    Callback = function()
        local success, result = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/RudertTiktok/OXJSOKAJSKSHS/refs/heads/main/pingOptimizerByRudert.txt"))()
        end)

        if success then
            WindUI:Notify({
                Title = "Ping Booster",
                Content = "Ping Booster UI loaded successfully!",
                Duration = 5,
                Icon = "network-wired"
            })
        else
            WindUI:Notify({
                Title = "Ping Booster",
                Content = "Failed to load Ping Booster UI: " .. tostring(result),
                Duration = 7,
                Icon = "alert-octagon"
            })
        end
    end
})

Tabs.Misc:Section({ Title = "Auto Rewards" })

Tabs.Misc:Toggle({
    Title = "Auto Rewards",
    Icon = "gift",
    Value = false,
    Callback = function(state)
        Config.auto_rewards = state
        WindUI:Notify({
            Title = "Auto Rewards",
            Content = "Auto Rewards " .. (state and "enabled" or "disabled"),
            Duration = 5,
            Icon = "gift"
        })
    end
})

Tabs.Misc:Section({ Title = "Quantum Arena" })

Tabs.Misc:Toggle({
    Title = "Disable Quantum Effects",    
    Value = false,
    Callback = function(state)
        Config.disable_quantum_effects = state
        WindUI:Notify({
            Title = "Quantum Effects",
            Content = "Quantum Effects " .. (state and "disabled" or "enabled"),
            Duration = 5            
        })
    end
})

Tabs.Misc:Section({ Title = "Announcer" })

Tabs.Misc:Toggle({
    Title = "Custom Announcer",
    Value = false,
    Callback = function(state)
        CustomAnnouncer.enabled = state
        Config.custom_announcer = state
        if state then
            CustomAnnouncer:updateAnnouncer()
        else
            if ConnectionsManager['announcer_text_changed'] then
                ConnectionsManager['announcer_text_changed']:Disconnect()
                ConnectionsManager['announcer_text_changed'] = nil
            end
        end
        WindUI:Notify({
            Title = "Custom Announcer",
            Content = "Custom Announcer " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
        })
    end
})

Tabs.Misc:Divider()

Tabs.Misc:Input({
    Title = "Custom Announcer Text",
    Placeholder = "Enter custom announcer text...",
    Callback = function(text)
        CustomAnnouncer.custom_text = text
        Config.announcer_text = text
        if CustomAnnouncer.enabled then
            CustomAnnouncer:updateAnnouncer()
        end
        WindUI:Notify({
            Title = "Custom Announcer Text",
            Content = "Text set to: " .. text,
            Duration = 0.5,
        })
    end
})

Tabs.Misc:Section({ Title = "Crate" })

Tabs.Misc:Button({
    Title = "Open Sword Crate",
    Icon = "package",
    Callback = function()
        local result = getSword()
        if result == "Error" then
            WindUI:Notify({
                Title = "Sword Crate",
                Content = "Failed to open sword crate!",
                Duration = 0.5,
                Icon = "alert-triangle"
            })
        else
            WindUI:Notify({
                Title = "Sword Crate",
                Content = "Opened sword crate: " .. tostring(result),
                Duration = 0.5,
                Icon = "package"
            })
        end
    end
})

Tabs.Misc:Button({
    Title = "Open Explosion Crate",
    Icon = "package",
    Callback = function()
        local result = getExplosion()
        if result == "Error" then
            WindUI:Notify({
                Title = "Explosion Crate",
                Content = "Failed to open explosion crate!",
                Duration = 0.5,
                Icon = "alert-triangle"
            })
        else
            WindUI:Notify({
                Title = "Explosion Crate",
                Content = "Opened explosion crate: " .. tostring(result),
                Duration = 0.5,
                Icon = "package"
            })
        end
    end
})

Tabs.Misc:Section({ Title = "Strafe Speed" })

Tabs.Misc:Toggle({
    Title = "Strafe",
    Icon = "move",
    Value = false,
    Callback = function(state)
        getgenv().Config.strafe = state
        WindUI:Notify({
            Title = "Strafe",
            Content = "Strafe " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "move"
        })
    end
})

Tabs.Misc:Divider()

Tabs.Misc:Slider({
    Title = "Speed",
    Icon = "gauge",
    Value = { Min = 0, Max = 100, Default = 50 },
    Callback = function(value)
        getgenv().Config.strafe_speed = value
        WindUI:Notify({
            Title = "Strafe Speed",
            Content = "Strafe Speed set to " .. value,
            Duration = 0.5,
            Icon = "gauge"
        })
    end
})

Tabs.Misc:Section({ Title = "Fly Over" })

Tabs.Misc:Toggle({
    Title = "Fly (mobile and PC work)",
    Icon = "cloud",
    Value = false,
    Callback = function(state)
        local flyConnection, resetterConnection, ragdollHandler, screenGui, flyControlsContainer
        local toggleButton, forwardButton, backButton, leftButton, rightButton, upButton, downButton, uiToggleButton
        local inputFlags = { forward = false, back = false, left = false, right = false, up = false, down = false }
        local uiVisible = true
        local dpadSize = UDim2.new(0, 60, 0, 60)
        
        local function createButton(parent, name, text, pos, size)
            local btn = Instance.new("TextButton")
            btn.Name = name
            btn.Text = text
            btn.Size = size
            btn.Position = pos
            btn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            btn.TextColor3 = Color3.fromRGB(255, 255, 255)
            btn.Font = Enum.Font.GothamBold
            btn.TextScaled = true
            btn.BackgroundTransparency = 0.2
            btn.Parent = parent
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 12)
            corner.Parent = btn
            return btn
        end
        
        local function tweenFlyControls(visible)
            local tweenTime = 0.5
            for _, btn in pairs(flyControlsContainer:GetChildren()) do
                if btn:IsA("TextButton") then
                    local targetBackgroundTransparency = visible and 0.2 or 1
                    local targetTextTransparency = visible and 0 or 1
                    local tweenInfo = TweenInfo.new(tweenTime, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                    local tween = TweenService:Create(btn, tweenInfo, { BackgroundTransparency = targetBackgroundTransparency, TextTransparency = targetTextTransparency })
                    tween:Play()
                end
            end
        end
        
        local function addTouchEvents(button, flagName)
            button.MouseButton1Down:Connect(function() inputFlags[flagName] = true end)
            button.MouseButton1Up:Connect(function() inputFlags[flagName] = false end)
            button.MouseLeave:Connect(function() inputFlags[flagName] = false end)
            button.TouchTap:Connect(function() inputFlags[flagName] = not inputFlags[flagName] end) -- Support tap
        end
        
        if state then
            getgenv().FlyEnabled = true
            local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local hrp = char:WaitForChild("HumanoidRootPart")
            local humanoid = char:WaitForChild("Humanoid")
            
            if not hrp or not humanoid then
                WindUI:Notify({
                    Title = "Fly Error",
                    Content = "Character not loaded!",
                    Duration = 0.5,
                    Icon = "alert-triangle"
                })
                return
            end
            
            -- Angkat karakter biar nggak stuck
            hrp.CFrame = hrp.CFrame + Vector3.new(0, 5, 0)
            
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            bodyVelocity.MaxForce = Vector3.new(50000, 50000, 50000)
            bodyVelocity.Parent = hrp
            
            local bodyGyro = Instance.new("BodyGyro")
            bodyGyro.CFrame = hrp.CFrame
            bodyGyro.MaxTorque = Vector3.new(50000, 50000, 50000)
            bodyGyro.P = 50000
            bodyGyro.Parent = hrp
            
            humanoid.PlatformStand = true
            
            ragdollHandler = humanoid.StateChanged:Connect(function(oldState, newState)
                if getgenv().FlyEnabled then
                    if newState == Enum.HumanoidStateType.Physics or newState == Enum.HumanoidStateType.Ragdoll then
                        task.defer(function()
                            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                            humanoid:ChangeState(Enum.HumanoidStateType.Running)
                        end)
                    end
                end
            end)
            
            resetterConnection = RunService.Heartbeat:Connect(function()
                if not getgenv().FlyEnabled then return end
                if bodyGyro and bodyGyro.Parent then
                    bodyGyro.P = 50000
                    bodyGyro.MaxTorque = Vector3.new(50000, 50000, 50000)
                end
                if bodyVelocity and bodyVelocity.Parent then
                    bodyVelocity.MaxForce = Vector3.new(50000, 50000, 50000)
                end
                humanoid.PlatformStand = true
                if not bodyGyro.Parent or not bodyVelocity.Parent then
                    if bodyGyro then bodyGyro:Destroy() end
                    if bodyVelocity then bodyVelocity:Destroy() end
                    bodyGyro = Instance.new("BodyGyro")
                    bodyGyro.P = 50000
                    bodyGyro.MaxTorque = Vector3.new(50000, 50000, 50000)
                    bodyGyro.Parent = hrp
                    bodyVelocity = Instance.new("BodyVelocity")
                    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                    bodyVelocity.MaxForce = Vector3.new(50000, 50000, 50000)
                    bodyVelocity.Parent = hrp
                end
            end)
            
            
            screenGui = Instance.new("ScreenGui")
            screenGui.Name = "FlyScreenGui"
            screenGui.ResetOnSpawn = false
            screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
            
            flyControlsContainer = Instance.new("Frame")
            flyControlsContainer.Name = "FlyControlsContainer"
            flyControlsContainer.Size = UDim2.new(1, 0, 1, 0)
            flyControlsContainer.BackgroundTransparency = 1
            flyControlsContainer.Parent = screenGui
            
            forwardButton = createButton(flyControlsContainer, "ForwardButton", "", UDim2.new(0, 70, 1, -190), dpadSize)
            backButton = createButton(flyControlsContainer, "BackButton", "", UDim2.new(0, 70, 1, -70), dpadSize)
            leftButton = createButton(flyControlsContainer, "LeftButton", "", UDim2.new(0, 10, 1, -130), dpadSize)
            rightButton = createButton(flyControlsContainer, "RightButton", "", UDim2.new(0, 130, 1, -130), dpadSize)
            upButton = createButton(flyControlsContainer, "UpButton", "Up", UDim2.new(1, -110, 1, -190), dpadSize)
            downButton = createButton(flyControlsContainer, "DownButton", "Down", UDim2.new(1, -110, 1, -70), dpadSize)
            uiToggleButton = createButton(flyControlsContainer, "UIToggleButton", "Hide UI", UDim2.new(0, 10, 0, 10), UDim2.new(0, 100, 0, 50))
            
            addTouchEvents(forwardButton, "forward")
            addTouchEvents(backButton, "back")
            addTouchEvents(leftButton, "left")
            addTouchEvents(rightButton, "right")
            addTouchEvents(upButton, "up")
            addTouchEvents(downButton, "down")
            
            uiToggleButton.MouseButton1Click:Connect(function()
                uiVisible = not uiVisible
                tweenFlyControls(uiVisible)
                uiToggleButton.Text = uiVisible and "Hide UI" or "Show UI"
            end)
            
            flyConnection = RunService.Heartbeat:Connect(function()
                if not getgenv().FlyEnabled then return end
                local moveDirection = Vector3.new(0, 0, 0)
                local camCF = workspace.CurrentCamera.CFrame
                
                if inputFlags.forward then moveDirection = moveDirection + camCF.LookVector end
                if inputFlags.back then moveDirection = moveDirection - camCF.LookVector end
                if inputFlags.left then moveDirection = moveDirection - camCF.RightVector end
                if inputFlags.right then moveDirection = moveDirection + camCF.RightVector end
                if inputFlags.up then moveDirection = moveDirection + Vector3.new(0, 1, 0) end
                if inputFlags.down then moveDirection = moveDirection - Vector3.new(0, 1, 0) end
                
                -- Kontrol PC (WASD/E/Q)
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                    moveDirection = moveDirection + camCF.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                    moveDirection = moveDirection - camCF.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                    moveDirection = moveDirection - camCF.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                    moveDirection = moveDirection + camCF.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.E) then
                    moveDirection = moveDirection + Vector3.new(0, 1, 0)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.Q) then
                    moveDirection = moveDirection - Vector3.new(0, 1, 0)
                end
                
                if moveDirection.Magnitude > 0 then
                    moveDirection = moveDirection.Unit
                end
                bodyVelocity.Velocity = moveDirection * (getgenv().FlySpeed or 30)
                bodyGyro.CFrame = camCF
            end)
            
            WindUI:Notify({
                Title = "Fly",
                Content = "Fly enabled! Use joystick to move, Up/Down to ascend/descend.",
                Duration = 5,
                Icon = "cloud"
            })
        else
            getgenv().FlyEnabled = false
            
            if flyConnection then
                flyConnection:Disconnect()
                flyConnection = nil
            end
            
            if resetterConnection then
                resetterConnection:Disconnect()
                resetterConnection = nil
            end
            
            if ragdollHandler then
                ragdollHandler:Disconnect()
                ragdollHandler = nil
            end
            
            if screenGui then
                screenGui:Destroy()
                screenGui = nil
            end
            
            local char = LocalPlayer.Character
            if char then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                local humanoid = char:FindFirstChild("Humanoid")
                
                if humanoid then
                    humanoid.PlatformStand = false
                    humanoid:ChangeState(Enum.HumanoidStateType.Running)
                end
                
                if hrp then
                    for _, v in ipairs(hrp:GetChildren()) do
                        if v:IsA("BodyGyro") or v:IsA("BodyVelocity") then
                            v:Destroy()
                        end
                    end
                end
            end
            
            WindUI:Notify({
                Title = "Fly",
                Content = "Fly disabled!",
                Duration = 0.5,
                Icon = "cloud"
            })
        end
        
        
        LocalPlayer.CharacterAdded:Connect(function(newChar)
            if getgenv().FlyEnabled then
                char = newChar
                hrp = newChar:WaitForChild("HumanoidRootPart")
                humanoid = newChar:WaitForChild("Humanoid")
                bodyVelocity.Parent = nil
                bodyGyro.Parent = nil
                humanoid.PlatformStand = false
                getgenv().FlyEnabled = false
                if flyConnection then flyConnection:Disconnect() end
                if resetterConnection then resetterConnection:Disconnect() end
                if ragdollHandler then ragdollHandler:Disconnect() end
                if screenGui then screenGui:Destroy() end
                WindUI:Notify({
                    Title = "Fly",
                    Content = "Fly disabled due to respawn!",
                    Duration = 0.5,
                    Icon = "cloud"
                })
            end
        end)
    end
})

Tabs.Misc:Section({ Title = "Detect Mod" })

Tabs.Misc:Toggle({
    Title = "Personnel Detector",
    Value = false,
    Callback = function(state)
        Config.personnel_detector = state
        WindUI:Notify({
            Title = "Personnel Detector",
            Content = "Personnel Detector " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
        })
    end
})

Tabs.Misc:Toggle({
    Title = "Auto Leave",
    Icon = "log-out",
    Value = false,
    Callback = function(state)
        Config.personnel_detector_auto_leave = state
        WindUI:Notify({
            Title = "Auto Leave",
            Content = "Auto Leave " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "log-out"
        })
    end
})

Tabs.Misc:Section({ Title = "Gravity World" })

Tabs.Misc:Toggle({
    Title = "Gravity",
    Value = false,
    Callback = function(state)
        Config.gravity = state
        WindUI:Notify({
            Title = "Gravity",
            Content = "Gravity " .. (state and "enabled" or "disabled"),
            Duration = 5,
        })
    end
})

Tabs.Misc:Divider()

Tabs.Misc:Slider({
    Title = "Gravity Strength",
    Icon = "sliders-horizontal",
    Value = { Min = 0, Max = 100, Default = 50 },
    Callback = function(value)
        Config.gravity_strength = value
        WindUI:Notify({
            Title = "Gravity Strength",
            Content = "Gravity Strength set to " .. value,
            Duration = 0.5,
            Icon = "sliders-horizontal"
        })
    end
})

Tabs.Players:Paragraph({
    Title = "Player Enchance",
    Desc = "Just suit yourself",    
    Color = "Green"
})

Tabs.Players:Section({ Title = "Player Follow" })

Tabs.Players:Toggle({
    Title = "Player Follow",
    Value = false,
    Callback = function(state)
        Config.player_follow = state
        if state then
            -- Start following connection
            ConnectionsManager['player_follow'] = RunService.Heartbeat:Connect(function()
                PlayerFollow:startFollowing()
            end)
            -- Start player list update connection
            local updateTimer = 0
            ConnectionsManager['player_list_update'] = RunService.Heartbeat:Connect(function(dt)
                updateTimer = updateTimer + dt
                if updateTimer >= 10 then
                    PlayerFollow:updatePlayerList()
                    updateTimer = 0
                end
            end)
            WindUI:Notify({
                Title = "Player Follow",
                Content = "Player Follow enabled",
                Duration = 0.5,
                Icon = "user"
            })
        else
            -- Disconnect follow and update connections
            if ConnectionsManager['player_follow'] then
                ConnectionsManager['player_follow']:Disconnect()
                ConnectionsManager['player_follow'] = nil
            end
            if ConnectionsManager['player_list_update'] then
                ConnectionsManager['player_list_update']:Disconnect()
                ConnectionsManager['player_list_update'] = nil
            end
            WindUI:Notify({
                Title = "Player Follow",
                Content = "Player Follow disabled",
                Duration = 5,
                Icon = "user"
            })
        end
    end
})

Tabs.Players:Divider()

local initialPlayerNames = PlayerFollow:getPlayerNames()
Tabs.Players:Dropdown({
    Title = "Follow Target",
    Values = initialPlayerNames,
    Value = #initialPlayerNames > 0 and initialPlayerNames[1] or nil,
    Callback = function(value)
        Config.follow_target = value
        WindUI:Notify({
            Title = "Follow Target",
            Content = value and "Now following: " .. value or "No target selected",
            Duration = 0.5,
            Icon = "user"
        })
    end
})

Tabs.Players:Section({ Title = "Cosmetics" })

Tabs.Players:Toggle({
    Title = "Player Cosmetics (Headless & Korblox)",
    Icon = "user-check",
    Value = false,
    Callback = function(value)
        _G.PlayerCosmeticsCleanup = _G.PlayerCosmeticsCleanup or {}
        local players = game:GetService("Players")
        local lp = players.LocalPlayer

        local function applyKorblox(character)
            local rightLeg = character:FindFirstChild("RightLeg") or character:FindFirstChild("Right Leg")
            if not rightLeg then
                warn("Right leg not found on character")
                return
            end
            for _, child in pairs(rightLeg:GetChildren()) do
                if child:IsA("SpecialMesh") then
                    child:Destroy()
                end
            end
            local specialMesh = Instance.new("SpecialMesh")
            specialMesh.MeshId = "rbxassetid://101851696"
            specialMesh.TextureId = "rbxassetid://115727863"
            specialMesh.Scale = Vector3.new(1, 1, 1)
            specialMesh.Parent = rightLeg
        end

        local function saveRightLegProperties(char)
            if char then
                local rightLeg = char:FindFirstChild("RightLeg") or char:FindFirstChild("Right Leg")
                if rightLeg then
                    local originalMesh = rightLeg:FindFirstChildOfClass("SpecialMesh")
                    if originalMesh then
                        _G.PlayerCosmeticsCleanup.originalMeshId = originalMesh.MeshId
                        _G.PlayerCosmeticsCleanup.originalTextureId = originalMesh.TextureId
                        _G.PlayerCosmeticsCleanup.originalScale = originalMesh.Scale
                    else
                        _G.PlayerCosmeticsCleanup.hadNoMesh = true
                    end
                    _G.PlayerCosmeticsCleanup.rightLegChildren = {}
                    for _, child in pairs(rightLeg:GetChildren()) do
                        if child:IsA("SpecialMesh") then
                            table.insert(_G.PlayerCosmeticsCleanup.rightLegChildren, {
                                ClassName = child.ClassName,
                                Properties = {
                                    MeshId = child.MeshId,
                                    TextureId = child.TextureId,
                                    Scale = child.Scale
                                }
                            })
                        end
                    end
                end
            end
        end

        local function restoreRightLeg(char)
            if char then
                local rightLeg = char:FindFirstChild("RightLeg") or char:FindFirstChild("Right Leg")
                if rightLeg and _G.PlayerCosmeticsCleanup.rightLegChildren then
                    for _, child in pairs(rightLeg:GetChildren()) do
                        if child:IsA("SpecialMesh") then
                            child:Destroy()
                        end
                    end
                    if _G.PlayerCosmeticsCleanup.hadNoMesh then
                        return
                    end
                    for _, childData in ipairs(_G.PlayerCosmeticsCleanup.rightLegChildren) do
                        if childData.ClassName == "SpecialMesh" then
                            local newMesh = Instance.new("SpecialMesh")
                            newMesh.MeshId = childData.Properties.MeshId
                            newMesh.TextureId = childData.Properties.TextureId
                            newMesh.Scale = childData.Properties.Scale
                            newMesh.Parent = rightLeg
                        end
                    end
                end
            end
        end

        if value then
            CosmeticsActive = true
            Config = Config or {}
            Config.Headless = true
            if lp.Character then
                local head = lp.Character:FindFirstChild("Head")
                if head and getgenv().Config.Headless then
                    _G.PlayerCosmeticsCleanup.headTransparency = head.Transparency
                    local decal = head:FindFirstChildOfClass("Decal")
                    if decal then
                        _G.PlayerCosmeticsCleanup.faceDecalId = decal.Texture
                        _G.PlayerCosmeticsCleanup.faceDecalName = decal.Name
                    end
                end
                saveRightLegProperties(lp.Character)
                applyKorblox(lp.Character)
            end
            _G.PlayerCosmeticsCleanup.characterAddedConn = lp.CharacterAdded:Connect(function(char)
                local head = char:FindFirstChild("Head")
                if head and getgenv().Config.Headless then
                    _G.PlayerCosmeticsCleanup.headTransparency = head.Transparency
                    local decal = head:FindFirstChildOfClass("Decal")
                    if decal then
                        _G.PlayerCosmeticsCleanup.faceDecalId = decal.Texture
                        _G.PlayerCosmeticsCleanup.faceDecalName = decal.Name
                    end
                end
                saveRightLegProperties(char)
                applyKorblox(char)
            end)
            if Config.Headless then
                headLoop = task.spawn(function()
                    while CosmeticsActive do
                        local char = lp.Character
                        if char then
                            local head = char:FindFirstChild("Head")
                            if head then
                                head.Transparency = 1
                                local decal = head:FindFirstChildOfClass("Decal")
                                if decal then
                                    decal:Destroy()
                                end
                            end
                        end
                        task.wait(0.1)
                    end
                end)
            end
        else
            CosmeticsActive = false
            if _G.PlayerCosmeticsCleanup.characterAddedConn then
                _G.PlayerCosmeticsCleanup.characterAddedConn:Disconnect()
                _G.PlayerCosmeticsCleanup.characterAddedConn = nil
            end
            if headLoop then
                task.cancel(headLoop)
                headLoop = nil
            end
            local char = lp.Character
            if char then
                local head = char:FindFirstChild("Head")
                if head and _G.PlayerCosmeticsCleanup.headTransparency ~= nil then
                    head.Transparency = _G.PlayerCosmeticsCleanup.headTransparency
                    if _G.PlayerCosmeticsCleanup.faceDecalId then
                        local newDecal = head:FindFirstChildOfClass("Decal") or Instance.new("Decal", head)
                        newDecal.Name = _G.PlayerCosmeticsCleanup.faceDecalName or "face"
                        newDecal.Texture = _G.PlayerCosmeticsCleanup.faceDecalId
                        newDecal.Face = Enum.NormalId.Front
                    end
                end
                restoreRightLeg(char)
            end
            _G.PlayerCosmeticsCleanup = {}
        end
        WindUI:Notify({
            Title = "Player Cosmetics",
            Content = "Cosmetics " .. (value and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "user-check"
        })
    end
})

Tabs.Players:Section({ Title = "FOV Camera" })

Tabs.Players:Toggle({
    Title = "Camera",
    Icon = "camera",
    Value = false,
    Callback = function(state)
        Config.camera = state
        WindUI:Notify({
            Title = "Camera",
            Content = "Camera " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "camera"
        })
    end
})

Tabs.Players:Divider()

Tabs.Players:Slider({
    Title = "Field Of View",
    Icon = "maximize",
    Value = { Min = 0, Max = 120, Default = 70 },
    Callback = function(value)
        Config.field_of_view = value
        WindUI:Notify({
            Title = "Field Of View",
            Content = "Field Of View set to " .. value,
            Duration = 0.5,
            Icon = "maximize"
        })
    end
})

Tabs.Players:Section({ Title = "Ability VB" })

Tabs.Players:Toggle({
    Title = "Ability Vulnerability",
    Icon = "shield-off",
    Value = false,
    Callback = function(state)
        Config.ability_vulnerability = state
        WindUI:Notify({
            Title = "Ability Vulnerability",
            Content = "Ability Vulnerability " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "shield-off"
        })
    end
})

Tabs.Players:Divider()

Tabs.Players:Dropdown({
    Title = "Mode",
    Icon = "chevrons-up-down",
    Values = { "Continuity Zero", "Quad Jump", "Quasar" },
    Value = "Quad Jump",
    Callback = function(option)
        Config.ability_vulnerability_mode = option
        WindUI:Notify({
            Title = "Ability Vulnerability Mode",
            Content = "Mode set to " .. option,
            Duration = 0.5,
            Icon = "chevrons-up-down"
        })
    end
})

Tabs.Farm:Paragraph({
    Title = "Farm!",
    Desc = "Farm Farm farm just to get coin huh?",    
    Color = "White"
})

Tabs.Farm:Section({ Title = "Auto Requeue", Icon = "refresh" })

local autoDuelsRequeueEnabled = false
Tabs.Farm:Toggle({
    Title = "Auto Duels Requeue",
    Desc = "Automatically requeues duels",
    Value = false,
    Callback = function(value)
        autoDuelsRequeueEnabled = value
        if value then
            task.spawn(function()
                while autoDuelsRequeueEnabled do
                    local success, err = pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.1.0"):WaitForChild("net"):WaitForChild("RE/PlayerWantsRematch"):FireServer()
                    end)
                    if not success then
                        WindUI:Notify({
                            Title = "Auto Duels Requeue",
                            Content = "Error: " .. tostring(err),
                            Duration = 0.5,
                            Icon = "alert"
                        })
                    end
                    task.wait(5)
                end
            end)
            WindUI:Notify({
                Title = "Auto Duels Requeue",
                Content = "Started auto requeue for duels!",
                Duration = 0.5,
                Icon = "refresh"
            })
        else
            WindUI:Notify({
                Title = "Auto Duels Requeue",
                Content = "Stopped auto requeue for duels!",
                Duration = 0.5,
                Icon = "refresh"
            })
        end
    end
})

local validRankedPlaceIds = { 13772394625, 14915220621 }
local selectedQueue = "FFA"
local autoRequeueEnabled = false
Tabs.Farm:Toggle({
    Title = "Auto Ranked Requeue",
    Desc = "Automatically requeues Ranked",
    Value = false,
    Callback = function(value)
        autoRequeueEnabled = value
        if value then
            if not table.find(validRankedPlaceIds, game.PlaceId) then
                autoRequeueEnabled = false
                WindUI:Notify({
                    Title = "Auto Ranked Requeue",
                    Content = "Invalid place ID for Ranked mode!",
                    Duration = 0.5,
                    Icon = "alert-triangle"
                })
                return
            end
            task.spawn(function()
                while autoRequeueEnabled do
                    local success, err = pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("JoinQueue"):FireServer("Ranked", selectedQueue, "Normal")
                    end)
                    if not success then
                        WindUI:Notify({
                            Title = "Auto Ranked Requeue",
                            Content = "Error: " .. tostring(err),
                            Duration = 0.5,
                            Icon = "alert"
                        })
                    end
                    task.wait(5)
                end
            end)
            WindUI:Notify({
                Title = "Auto Ranked Requeue",
                Content = "Started auto requeue for Ranked!",
                Duration = 0.5,
                Icon = "refresh"
            })
        else
            WindUI:Notify({
                Title = "Auto Ranked Requeue",
                Content = "Stopped auto requeue for Ranked!",
                Duration = 0.5,
                Icon = "refresh"
            })
        end
    end
})

Tabs.Farm:Dropdown({
    Title = "Select Queue Type",
    Values = { "FFA", "Duo" },
    Value = "FFA",
    Callback = function(selectedOption)
        selectedQueue = selectedOption
        WindUI:Notify({
            Title = "Queue Type",
            Content = "Set queue type to: " .. selectedOption,
            Duration = 0.5,
            Icon = "list"
        })
    end
})

local autoLTMRequeueEnabled = false
local validLTMPlaceId = 13772394625
Tabs.Farm:Toggle({
    Title = "Auto LTM Requeue",
    Desc = "Automatically requeues LTM",
    Value = false,
    Callback = function(value)
        autoLTMRequeueEnabled = value
        if value then
            if game.PlaceId ~= validLTMPlaceId then
                autoLTMRequeueEnabled = false
                WindUI:Notify({
                    Title = "Auto LTM Requeue",
                    Content = "Invalid place ID for LTM mode!",
                    Duration = 0.5,
                    Icon = "alert-triangle"
                })
                return
            end
            task.spawn(function()
                while autoLTMRequeueEnabled do
                    local success, result = pcall(function()
                        return game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.1.0"):WaitForChild("net"):WaitForChild("RF/JoinTournamentEventQueue"):InvokeServer({})
                    end)
                    if not success then
                        WindUI:Notify({
                            Title = "Auto LTM Requeue",
                            Content = "Error: " .. tostring(result),
                            Duration = 0.5,
                            Icon = "alert"
                        })
                    end
                    task.wait(5)
                end
            end)
            WindUI:Notify({
                Title = "Auto LTM Requeue",
                Content = "Started auto requeue for LTM!",
                Duration = 0.5,
                Icon = "refresh"
            })
        else
            WindUI:Notify({
                Title = "Auto LTM Requeue",
                Content = "Stopped auto requeue for LTM!",
                Duration = 0.5,
                Icon = "refresh"
            })
        end
    end
})

Tabs.Farm:Section({ Title = "AI" })

Tabs.Farm:Toggle({
    Title = "AI Play V1 (Rage)",
    Icon = "bot",
    Value = Config.ai_play,
    Callback = function(state)
        Config.ai_play = state
        AIPlaying = state
        if AIPlaying then
            if AICoroutine then
                task.cancel(AICoroutine)
                AICoroutine = nil
            end
            AICoroutine = task.spawn(runAI)
            ConnectionsManager['ai_play'] = AICoroutine
        else
            if AICoroutine then
                task.cancel(AICoroutine)
                AICoroutine = nil
                ConnectionsManager['ai_play'] = nil
            end
        end
        WindUI:Notify({
            Title = "AI Play",
            Content = "AI Play " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "bot"
        })
    end
})

Tabs.Farm:Divider()

Tabs.Farm:Dropdown({
    Title = "AI Behavior",    
    Values = {"AdvancedPro", "BallChaser", "AggressiveHunter"},
    Value = "AdvancedPro",
    Callback = function(value)
        Config.ai_method = value
        AICurrentMethod = value
        AITarget = nil
        WindUI:Notify({
            Title = "AI Behavior",
            Content = "AI Behavior set to " .. value,
            Duration = 0.5,            
        })
    end
})

Tabs.Farm:Divider()

Tabs.Farm:Toggle({
    Title = "Ai Play V2 (Completed)",
    Value = Config.auto_play or false,
    Callback = function(state)
        Config.auto_play = state
        if state then
            AutoPlayModule.runThread()
            WindUI:Notify({
                Title = "Auto Play",
                Content = "Auto Play enabled",
                Duration = 0.5,
                Icon = "play"
            })
        else
            AutoPlayModule.finishThread()
            WindUI:Notify({
                Title = "Auto Play",
                Content = "Auto Play disabled",
                Duration = 0.5,
                Icon = "play"
            })
        end
    end
})

Tabs.Farm:Toggle({
    Title = "Enable Jumping Ai",
    Value = true,
    Callback = function(state)        
        AutoPlayModule.CONFIG.JUMPING_ENABLED = state
        WindUI:Notify({
            Title = "Jumping",
            Content = "Jumping " .. (state and "enabled" or "disabled"),
            Duration = 0.5,
            Icon = "arrow-up"
        })
    end
})

Tabs.Farm:Divider()

Tabs.Farm:Slider({
    Title = "Distance From Ball",    
    Value = { Min = 5, Max = 100, Default = 30 },    
    Callback = function(value)
        Config.default_distance = value
        AutoPlayModule.CONFIG.DEFAULT_DISTANCE = value
        WindUI:Notify({
            Title = "Distance From Ball",
            Content = "Set to " .. value,
            Duration = 0.5,
            Icon = "ruler"
        })
    end
})

Tabs.Farm:Slider({
    Title = "Speed Multiplier",    
    Value = { Min = 10, Max = 200, Default = 70 },   
    Callback = function(value)        
        AutoPlayModule.CONFIG.MULTIPLIER_THRESHOLD = value
        WindUI:Notify({
            Title = "Speed Multiplier",
            Content = "Set to " .. value,
            Duration = 0.5,
            Icon = "speedometer"
        })
    end
})

Tabs.Farm:Slider({
    Title = "Traversing",
    Min = 0,
    Max = 100,
    Value = { Min = 0, Max = 100, Default = 25 },
    Callback = function(value)        
        AutoPlayModule.CONFIG.TRAVERSING = value
        WindUI:Notify({
            Title = "Traversing",
            Content = "Set to " .. value,
            Duration = 0.5,
            Icon = "move"
        })
    end
})

Tabs.Farm:Slider({
    Title = "Direction",
    Min = -1,
    Max = 1,
    Value = { Min = -1, Max = 1, Default = 1 },
    Callback = function(value)       
        AutoPlayModule.CONFIG.DIRECTION = value
        WindUI:Notify({
            Title = "Direction",
            Content = "Set to " .. value,
            Duration = 0.5,
            Icon = "arrow-right"
        })
    end
})

Tabs.Farm:Slider({
    Title = "Offset Factor",
    Min = 0.1,
    Max = 1,
    Value = { Min = 0.1, Max = 1, Default = 0.7 },
    Callback = function(value)        
        AutoPlayModule.CONFIG.OFFSET_FACTOR = value
        WindUI:Notify({
            Title = "Offset Factor",
            Content = "Set to " .. value,
            Duration = 0.5,
            Icon = "adjust"
        })
    end
})

Tabs.Farm:Slider({
    Title = "Movement Duration",    
    Value = { Min = 0.1, Max = 1, Default = 0.8 },
    Callback = function(value)        
        AutoPlayModule.CONFIG.MOVEMENT_DURATION = value
        WindUI:Notify({
            Title = "Movement Duration",
            Content = "Set to " .. value,
            Duration = 0.5,
            Icon = "timer"
        })
    end
})

Tabs.Farm:Slider({
    Title = "Generation Threshold",
    Min = 0.1,
    Max = 0.5,
    Value = { Min = 0.1, Max = 0.5, Default = 0.25 },
    Callback = function(value)        
        AutoPlayModule.CONFIG.GENERATION_THRESHOLD = value
        WindUI:Notify({
            Title = "Generation Threshold",
            Content = "Set to " .. value,
            Duration = 0.5,
            Icon = "clock"
        })
    end
})

Tabs.Farm:Slider({
    Title = "Jump Chance",    
    Value = { Min = 0, Max = 100, Default = 50 },
    Callback = function(value)        
        AutoPlayModule.CONFIG.JUMP_PERCENTAGE = value
        WindUI:Notify({
            Title = "Jump Chance",
            Content = "Set to " .. value .. "%",
            Duration = 0.5,
            Icon = "arrow-up"
        })
    end
})

Tabs.Farm:Slider({
    Title = "Double Jump Chance",   
    Value = { Min = 0, Max = 100, Default = 50 },
    Callback = function(value)       
        AutoPlayModule.CONFIG.DOUBLE_JUMP_PERCENTAGE = value
        WindUI:Notify({
            Title = "Double Jump Chance",
            Content = "Set to " .. value .. "%",
            Duration = 0.5,
            Icon = "arrow-up"
        })
    end
})

Tabs.Farm:Section({ Title = "Orbit Farm" })

Tabs.Farm:Toggle({
    Title = "Auto Farm Orbit (V2)",
    Value = false,
    Callback = function(state)
        auto_farm_enabled = state
        if state then
            if auto_farm_connection then
                auto_farm_connection:Disconnect()
                auto_farm_connection = nil
            end
            auto_farm_connection = RunService.Heartbeat:Connect(function()
                if not auto_farm_enabled then return end
                local rootPart = LocalPlayer.Character and (LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or LocalPlayer.Character.PrimaryPart)
                if not rootPart then return end
                local ball = AutoParry.get_ball()
                if not ball then return end

                local position = ball.Position
                local angle = tick() * math.pi * 2 / (auto_farm_orbit / 5)
                local time = tick()

                if auto_farm_type == "UnderBall" then
                    rootPart.CFrame = CFrame.new(position - Vector3.new(0, auto_farm_height, 0))
                elseif auto_farm_type == "X Orbit" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.cos(angle) * auto_farm_radius,
                        0,
                        math.sin(angle) * auto_farm_radius
                    ))
                elseif auto_farm_type == "Y Orbit" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        0,
                        math.sin(angle) * auto_farm_radius,
                        math.cos(angle) * auto_farm_radius
                    ))
                elseif auto_farm_type == "Z Orbit" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.cos(angle) * auto_farm_radius,
                        math.sin(angle) * auto_farm_radius,
                        0
                    ))
                elseif auto_farm_type == "Helix" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.cos(angle) * auto_farm_radius,
                        math.sin(time) * auto_farm_height,
                        math.sin(angle) * auto_farm_radius
                    ))
                elseif auto_farm_type == "Figure8" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.cos(angle) * auto_farm_radius,
                        0,
                        math.sin(2 * angle) * (auto_farm_radius / 2)
                    ))
                elseif auto_farm_type == "Spiral" then
                    local spiralRadius = auto_farm_radius * (1 + math.sin(time * 0.5))
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.cos(angle) * spiralRadius,
                        time % auto_farm_height,
                        math.sin(angle) * spiralRadius
                    ))
                elseif auto_farm_type == "Random Orbit" then
                    rootPart.CFrame = CFrame.new(position + Vector3.new(
                        math.noise(time) * auto_farm_radius,
                        math.noise(time + 10) * auto_farm_height,
                        math.noise(time + 20) * auto_farm_radius
                    ))
                end
            end)
        elseif auto_farm_connection then
            auto_farm_connection:Disconnect()
            auto_farm_connection = nil
        end
    end
})

Tabs.Farm:Divider()

Tabs.Farm:Dropdown({
    Title = "Auto Farm Type",
    Values = {"UnderBall", "X Orbit", "Y Orbit", "Z Orbit", "Helix", "Figure8", "Spiral", "Random Orbit"},
    Value = "Random Orbit",
    Multi = false,
    Callback = function(selected)
        auto_farm_type = selected
    end
})

Tabs.Farm:Slider({
    Title = "Orbit Speed",
    Value = { Min = 1, Max = 20, Default = 5 },
    Callback = function(value)
        auto_farm_orbit = value
    end
})

Tabs.Farm:Slider({
    Title = "Orbit Height",
    Value = { Min = 0, Max = 50, Default = 10 },
    Callback = function(value)
        auto_farm_height = value
    end
})

Tabs.Farm:Slider({
    Title = "Orbit Radius",
    Value = { Min = 5, Max = 50, Default = 20 },
    Callback = function(value)
        auto_farm_radius = value
    end
})

Tabs.Settings:Paragraph({
    Title = "A Settings", 
    Desc =  "Ambatublow",    
    Color = "Red"
})



Tabs.Settings:Section({ Title = "Teleport", Icon = "plane" })

Tabs.Settings:Button({
    Title = "Rejoin",
    Icon = "refresh-cw",
    Callback = function()
        local teleportService = game:GetService("TeleportService")
        local success, result = pcall(function()
            teleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, game:GetService("Players").LocalPlayer)
        end)
        if success then
            WindUI:Notify({
                Title = "Rejoin",
                Content = "Rejoining current server",
                Duration = 0.5,
                Icon = "refresh-cw"
            })
        else
            WindUI:Notify({
                Title = "Rejoin Failed",
                Content = "Failed to rejoin: " .. tostring(result),
                Duration = 0.5,
                Icon = "alert-triangle"
            })
        end
    end
})

Tabs.Settings:Button({
    Title = "Teleport To Mobile Server",
    Icon = "plane",
    Callback = function()
        local teleportService = game:GetService("TeleportService")
        local success, result = pcall(function()
            teleportService:TeleportToPlaceInstance(15509350986, nil, game:GetService("Players").LocalPlayer)
        end)
        if success then
            WindUI:Notify({
                Title = "Teleporting",
                Content = "Teleporting to Mobile server",
                Duration = 0.5,
                Icon = "plane"
            })
        else
            WindUI:Notify({
                Title = "Teleport Failed",
                Content = "Failed to find Mobile server: " .. tostring(result),
                Duration = 0.5,
                Icon = "alert-triangle"
            })
        end
    end
})

Tabs.Settings:Button({
    Title = "Teleport To PC Server",
    Icon = "plane",
    Callback = function()
        local teleportService = game:GetService("TeleportService")
        local success, result = pcall(function()
            teleportService:TeleportToPlaceInstance(14732610803, nil, game:GetService("Players").LocalPlayer)
        end)
        if success then
            WindUI:Notify({
                Title = "Teleporting",
                Content = "Teleporting to PC server",
                Duration = 0.5,
                Icon = "plane"
            })
        else
            WindUI:Notify({
                Title = "Teleport Failed",
                Content = "Failed to find PC server: " .. tostring(result),
                Duration = 0.5,
                Icon = "alert-triangle"
            })
        end
    end
})

Tabs.Settings:Button({
    Title = "Teleport To VC Server",
    Icon = "plane",
    Callback = function()
        local teleportService = game:GetService("TeleportService")
        local success, result = pcall(function()
            teleportService:TeleportToPlaceInstance(15131065025, nil, game:GetService("Players").LocalPlayer)
        end)
        if success then
            WindUI:Notify({
                Title = "Teleporting",
                Content = "Teleporting to VC server",
                Duration = 0.5,
                Icon = "plane"
            })
        else
            WindUI:Notify({
                Title = "Teleport Failed",
                Content = "Failed to find VC server: " .. tostring(result),
                Duration = 0.5,
                Icon = "alert-triangle"
            })
        end
    end
})

Tabs.Theme:Section({ Title = "Custom Theme", Icon = "palette" })

local currentThemeName = "BladeDark"
local ThemeAccent = "#FF0000"
local ThemeOutline = "#000000"
local ThemeText = "#FFFFFF"
local ThemePlaceholderText = "#666666"
local themeValues = {}
for name, _ in pairs(WindUI:GetThemes()) do
    table.insert(themeValues, name)
end

local themeDropdown = Tabs.Theme:Dropdown({
    Title = "Select Theme",
    Multi = false,
    AllowNone = false,
    Value = nil,
    Values = themeValues,
    Callback = function(theme)
        WindUI:SetTheme(theme)
    end
})
themeDropdown:Select(WindUI:GetCurrentTheme())

local ToggleTransparency = Tabs.Theme:Toggle({
    Title = "Toggle Window Transparency",
    Callback = function(e)
        Window:ToggleTransparency(e)
    end,
    Value = WindUI:GetTransparency()
})

function updateTheme()
    WindUI:AddTheme({
        Name = currentThemeName,
        Accent = ThemeAccent,
        Outline = ThemeOutline,
        Text = ThemeText,
        Placeholder = ThemePlaceholderText
    })
    WindUI:SetTheme(currentThemeName)
    WindUI:Notify({
        Title = "Theme Updated",
        Content = "Applied custom theme: " .. currentThemeName,
        Duration = 5,
        Icon = "palette"
    })
end

Tabs.Theme:Divider()

Tabs.Theme:Input({
    Title = "Theme Name",
    Icon = "type",
    Value = currentThemeName,
    Callback = function(name)
        currentThemeName = name
        WindUI:Notify({
            Title = "Theme Name",
            Content = "Theme name set to " .. name,
            Duration = 5,
            Icon = "type"
        })
    end
})

Tabs.Theme:Colorpicker({
    Title = "Accent Color",
    Icon = "paintbrush",
    Default = Color3.fromHex(ThemeAccent),
    Callback = function(color)
        ThemeAccent = color:ToHex()
        WindUI:Notify({
            Title = "Accent Color",
            Content = "Accent color set to " .. color:ToHex(),
            Duration = 5,
            Icon = "paintbrush"
        })
    end
})

Tabs.Theme:Colorpicker({
    Title = "Outline Color",
    Icon = "paintbrush",
    Default = Color3.fromHex(ThemeOutline),
    Callback = function(color)
        ThemeOutline = color:ToHex()
        WindUI:Notify({
            Title = "Outline Color",
            Content = "Outline color set to " .. color:ToHex(),
            Duration = 5,
            Icon = "paintbrush"
        })
    end
})

Tabs.Theme:Colorpicker({
    Title = "Text Color",
    Icon = "paintbrush",
    Default = Color3.fromHex(ThemeText),
    Callback = function(color)
        ThemeText = color:ToHex()
        WindUI:Notify({
            Title = "Text Color",
            Content = "Text color set to " .. color:ToHex(),
            Duration = 5,
            Icon = "paintbrush"
        })
    end
})

local InviteCode = "pbUCMc8VFs"
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

local Response = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
    Url = DiscordAPI,
    Method = "GET",
    Headers = {
        ["User-Agent"] = "RobloxBot/1.0",
        ["Accept"] = "application/json"
    }
}).Body)

if Response and Response.guild then
    local DiscordInfo = Tabs.Info:Paragraph({
        Title = Response.guild.name,
        Desc = 
            ' <font color="#52525b"></font> Member Count : ' .. tostring(Response.approximate_member_count) .. 
            '\n <font color="#16a34a"></font> Online Count : ' .. tostring(Response.approximate_presence_count)
        ,
        Image = "https://cdn.discordapp.com/icons/" .. Response.guild.id .. "/" .. Response.guild.icon .. ".png?size=1024",
        ImageSize = 42,
    })

    Tabs.Info:Button({
        Title = "Update Info",
        Image = "refresh-ccw",
        Callback = function()
            local UpdatedResponse = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
                Url = DiscordAPI,
                Method = "GET",
            }).Body)
            
            if UpdatedResponse and UpdatedResponse and UpdatedResponse.guild then
                DiscordInfo:SetDesc(
                    ' <font color="#52525b"></font> Member Count : ' .. tostring(UpdatedResponse.approximate_member_count) .. 
                    '\n <font color="#16a34a"></font> Online Count : ' .. tostring(UpdatedResponse.approximate_presence_count)
                )
            end
        end
    })
else
    Tabs.Info:Paragraph({
        Title = "Error when receiving information about the Discord server",
        Desc = game:GetService("HttpService"):JSONEncode(Response),
        Image = "triangle-alert",
        ImageSize = 26,
        Color = "Red",
    })
end

local LocalPlayer = Players.LocalPlayer

LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.zero)
end)

local function updateIndicator()
    if not getgenv().BallDirectionIndicator or not ScreenGui.Enabled then
        Arrow.Visible = false        
        return
    end
    local ball = AutoParry.ball.ball_entity
    if not ball or not AutoParry.ball.properties or not AutoParry.ball.properties.position then
        Arrow.Visible = false       
        return
    end
    local playerChar = player.Character
    local playerHrp = playerChar and playerChar:FindFirstChild("HumanoidRootPart")
    if not playerHrp then
        Arrow.Visible = false       
        return
    end
    local ball_position = AutoParry.ball.properties.position
    local distance = AutoParry.ball.properties.distance or (playerHrp.Position - ball_position).Magnitude
    
    local color
    if distance < 30 then
        color = Color3.new(1, 1, 1) -- Putih (dekat)
    elseif distance < 100 then
        color = Color3.new(1, 1, 0) -- Kuning (sedang)
    else
        color = Color3.new(1, 0, 0) -- Merah (jauh)
    end
    Arrow.ImageColor3 = color
    
    local viewportSize = cam.ViewportSize
    local screenCenter = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    local screenPoint, onScreen = cam:WorldToViewportPoint(ball_position)
    
    Arrow.Visible = true
    local offset = 50
    local direction = Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter
    if direction.Magnitude < 0.01 then
        Arrow.Visible = false        
        return
    end
    direction = direction.Unit
    local edgeX = screenCenter.X + direction.X * offset
    local edgeY = screenCenter.Y + direction.Y * offset

    local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tween = tweenService:Create(Arrow, tweenInfo, {Position = UDim2.new(0, edgeX, 0, edgeY)})
    tween:Play()

    
    local angle = math.atan2(direction.Y, direction.X)
    Arrow.Rotation = math.deg(angle) + 280
    
    local ping = Player.Entity.properties.ping or 0
    local ping_threshold = math.clamp(ping / 10, 13, 19)    
    local speed_factor = (ping_threshold + AutoParry.ball.properties.speed) * 1.58       
    Arrow.ImageTransparency = distance <= ping_threshold and 0 or 0.5
end

ConnectionsManager['ball_direction_indicator'] = RunService.RenderStepped:Connect(updateIndicator)






local self = AutoParry.ball.ball_entity
    local Visualize = Instance.new("Part",workspace)
    Visualize.Color = Color3.new(1, 1, 1)
    Visualize.Material = Enum.Material.ForceField
    Visualize.Transparency = 0.5
    Visualize.Anchored = true
    Visualize.CanCollide = false
    Visualize.CastShadow = false
    Visualize.Shape = Enum.PartType.Ball
    Visualize.Size = Vector3.new(30,30,30)
    local Popobd = Instance.new("Part",workspace)
    Popobd.Color = Color3.new(1, 0, 1)
    Popobd.Material = Enum.Material.ForceField
    Popobd.Transparency = 0.5
    Popobd.Anchored = true
    Popobd.CanCollide = false
    Popobd.CastShadow = false
    Popobd.Shape = Enum.PartType.Ball
    Popobd.Size = Vector3.new(30,30,30)
    local jihag = Instance.new("Part",workspace)
    jihag.Color = Color3.new(0, 0, 1)
    jihag.Material = Enum.Material.ForceField
    jihag.Transparency = 0.5
    jihag.Anchored = true
    jihag.CanCollide = false
    jihag.CastShadow = false
    jihag.Shape = Enum.PartType.Ball
    jihag.Size = Vector3.new(30,30,30)
    local Popobdm = Instance.new("Highlight")
    Popobdm.Parent = Popobd
    Popobdm.Enabled = true
    Popobdm.FillTransparency = 0
    Popobdm.OutlineColor = Color3.new(1, 1, 1)
    local jihagm = Instance.new("Highlight")
    jihagm.Parent = jihag
    jihagm.Enabled = true
    jihagm.FillTransparency = 0
    jihagm.OutlineColor = Color3.new(1, 1, 1)
    local Highlight = Instance.new("Highlight")
    Highlight.Parent = Visualize
    Highlight.Enabled = true
    Highlight.FillTransparency = 0
    Highlight.OutlineColor = Color3.new(1, 1, 1)
    
    RunService.PreSimulation:Connect(function()
        if Config.visualize_Enabled and LocalPlayer then
            Visualize.Transparency = 0
            Visualize.Material = Enum.Material.ForceField
            Visualize.Size = Vector3.new(AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range)
            Visualize.CFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position)
            Popobd.Transparency = 0
            Popobd.Material = Enum.Material.ForceField
            Popobd.Size = Vector3.new(AutoParry.ball.properties.distance,AutoParry.ball.properties.distance,AutoParry.ball.properties.distance)
            Popobd.CFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position)
            jihag.Transparency = 0
            jihag.Material = Enum.Material.ForceField
            jihag.Size = Vector3.new(AutoParry.ball.properties.speed,AutoParry.ball.properties.speed,AutoParry.ball.properties.speed)
            jihag.CFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position)
        else
            Visualize.Material = Enum.Material.ForceField
            Visualize.Transparency = 1
            Popobd.Material = Enum.Material.ForceField
            Popobd.Transparency = 1
            jihag.Material = Enum.Material.ForceField
            jihag.Transparency = 1
        end	
        if AutoParry.ball.properties.auto_spam then
          Visualize.Color = Color3.new(1, 0, 0)
          Visualize.Size = Vector3.new(30, 30, 30)
        elseif not (AutoParry.target.current and AutoParry.target.current ~= LocalPlayer.Character) then
        Visualize.Color = Color3.new(0, 1, 0)
        Visualize.Size = Vector3.new(AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range)
        elseif AutoParry.ball.properties.distance < AutoParry.ball.properties.parry_range then
        Visualize.Color = Color3.new(0, 0, 0)
        Visualize.Size = Vector3.new(AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range,AutoParry.ball.properties.parry_range)
        else
          Visualize.Color = Color3.new(1, 1, 1)
        end
    end)


local function createBillboard(parent, name)
    if not parent or not parent:IsA("BasePart") or not parent.Parent then
        warn("createBillboard: Invalid or missing parent for " .. tostring(name))
        return nil
    end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = name
    billboard.Parent = parent
    billboard.Adornee = parent
    billboard.Size = UDim2.new(0, 200, 0, 70) -- Fits all text
    billboard.StudsOffset = Vector3.new(0, 3.5, 0)
    billboard.AlwaysOnTop = true
    billboard.MaxDistance = 80 -- Optimized for Android

    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "InfoTextLabel"
    textLabel.Parent = billboard
    textLabel.BackgroundTransparency = 1
    textLabel.Size = UDim2.new(0.9, 0, 0.9, 0) -- Padding
    textLabel.Position = UDim2.new(0.05, 0, 0.05, 0)
    textLabel.Font = Enum.Font.Gotham
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.TextScaled = false
    textLabel.TextSize = 14
    textLabel.TextWrapped = true
    textLabel.TextXAlignment = Enum.TextXAlignment.Left
    textLabel.TextYAlignment = Enum.TextYAlignment.Top
    textLabel.Text = ""

    local uiStroke = Instance.new("UIStroke")
    uiStroke.Name = "TextOutline"
    uiStroke.Parent = textLabel
    uiStroke.Color = Color3.fromRGB(0, 0, 0)
    uiStroke.Thickness = 1.5
    uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = textLabel

    return billboard
end

-- Assign to placeholder
updateBillboardText = function()
    local currentTime = tick()
    if currentTime - lastUpdateTime < 0.1 then return end
    lastUpdateTime = currentTime

    -- Update Ball Text
    if Config.ball_text_enabled then
        local ball = AutoParry.get_ball()
        if ball and ball:IsA("BasePart") and ball.Parent then
            -- Create or update billboard
            if not BallBillboard or BallBillboard.Adornee ~= ball then
                if BallBillboard then
                    BallBillboard:Destroy()
                    BallBillboard = nil
                end
                BallBillboard = createBillboard(ball, "BallInfoBillboard")
                if not BallBillboard then
                    warn("Failed to create BallBillboard")
                    return
                end
            end
            -- Update text and color
            local ball_properties = AutoParry.ball.properties
            local velocity = (typeof(ball_properties.velocity) == "Vector3" and ball_properties.velocity.Magnitude) or 0
            local is_curved = ball_properties.is_curved
            local range = ball_properties.distance or 0
            local isTargetPlayer = AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name
            if BallBillboard and BallBillboard.InfoTextLabel then
                BallBillboard.InfoTextLabel.Text = string.format(
                    "Velocity: %.1f\nCurved: %s\nRange: %.1f\nTarget: %s",
                    velocity, tostring(is_curved), range, tostring(isTargetPlayer)
                )
                local targetColor = (is_curved or isTargetPlayer) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255)
                if BallBillboard.InfoTextLabel.TextColor3 ~= targetColor then
                    create_animation(BallBillboard.InfoTextLabel, TweenInfo.new(0.5), {TextColor3 = targetColor})
                end
                BallBillboardEnabled = true                
            else
                warn("BallBillboard or InfoTextLabel is nil")
            end
        else
            if BallBillboard then
                BallBillboard:Destroy()
                BallBillboard = nil
                ballBillboardEnabled = false
            end
        end
    else
        if BallBillboard then
            BallBillboard:Destroy()
            BallBillboard = nil
            ballBillboardEnabled = false
        end
    end

   
    if Config.player_text_enabled then
        local player = LocalPlayer.Character
        local hrp = player and (player:FindFirstChild("HumanoidRootPart") or player.PrimaryPart)
        if hrp and hrp:IsA("BasePart") and hrp.Parent then
            -- Create or update billboard
            if not PlayerBillboard or PlayerBillboard.Adornee ~= hrp then
                if PlayerBillboard then
                    PlayerBillboard:Destroy()
                    PlayerBillboard = nil
                end
                PlayerBillboard = createBillboard(hrp, "PlayerInfoBillboard")
                if not PlayerBillboard then
                    warn("Failed to create PlayerBillboard")
                    return
                end
            end
            -- Update text and color
            local ball = AutoParry.get_ball()
            local range = ball and (hrp.Position - ball.Position).Magnitude or 0
            local auto_spam = AutoParry.ball.properties.auto_spam
            if PlayerBillboard and PlayerBillboard.InfoTextLabel then
                PlayerBillboard.InfoTextLabel.Text = string.format(
                    "Range to Ball: %.1f\nAutoSpam: %s",
                    range, tostring(auto_spam)
                )
                local targetColor = auto_spam and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 255)
                if PlayerBillboard.InfoTextLabel.TextColor3 ~= targetColor then
                    create_animation(PlayerBillboard.InfoTextLabel, TweenInfo.new(0.5), {TextColor3 = targetColor})
                end
                PlayerBillboardEnabled = true                
            else
                warn("PlayerBillboard or InfoTextLabel is nil")
            end
        else
            if PlayerBillboard then
                PlayerBillboard:Destroy()
                PlayerBillboard = nil
                playerBillboardEnabled = false
            end
        end
    else
        if PlayerBillboard then
            PlayerBillboard:Destroy()
            PlayerBillboard = nil
            playerBillboardEnabled = false -- Uncomment if using new variable
        end
    end
end

workspace.Balls.ChildRemoved:Connect(function(child)
    if BallBillboard and child == BallBillboard.Adornee then
        BallBillboard:Destroy()
        BallBillboard = nil       
    end
end)

workspace.Alive.ChildRemoved:Connect(function(player)
    if player == LocalPlayer.Character and PlayerBillboard then
        PlayerBillboard:Destroy()
        PlayerBillboard = nil        
    end
end)

if ConnectionsManager['billboard_text'] then
    ConnectionsManager['billboard_text']:Disconnect()
end
ConnectionsManager['billboard_text'] = RunService.Heartbeat:Connect(function()
    if updateBillboardText then
        updateBillboardText()
    else
        warn("updateBillboardText is nil in Heartbeat")
    end
end)
    
ConnectionsManager['camera_field_of_view'] = RunService.PostSimulation:Connect(function()
    if not workspace.CurrentCamera then
        return
    end
    local character = LocalPlayer.Character
    if not character then
        return
    end
    local camera_enabled = Config.camera
    local current_camera = workspace.CurrentCamera
    if not camera_enabled then
        current_camera.FieldOfView = 70
        return
    end
    local field_of_view = Config.field_of_view
    current_camera.FieldOfView = field_of_view
    if AutoParry.ball.client_ball_entity == nil or #workspace.Balls:GetChildren() == 0 then
        current_camera.CameraSubject = LocalPlayer.Character
        return
    end
end)

local spamming_done = true
ConnectionsManager['ability_vulnerability'] = RunService.PostSimulation:Connect(function()
    local ability_vulnerability_enabled = Config.ability_vulnerability
    if not ability_vulnerability_enabled then
        spamming_done = true
        return
    end
    local character = LocalPlayer.Character
    if not character or Player.Entity.properties.ping > 250 then
        return
    end
    local mode = Config.ability_vulnerability_mode
    if not spamming_done or not character.Abilities[mode].Enabled then
        return
    end
    if not mode or mode == 'Quad Jump' then
        spamming_done = false
        for threads = 1, 3650 do
            ReplicatedStorage.Remotes.XtraJumped:FireServer()
        end
        spamming_done = true
    elseif mode == 'Continuity Zero' and AutoParry.target.current ~= LocalPlayer.Character then
        spamming_done = false
        ReplicatedStorage.Remotes.UseContinuityPortal:FireServer(CFrame.new(tick(), tick(), tick(), tick(), tick(), tick(), tick()))
        task.delay(20, function()
            spamming_done = true
        end)
    elseif mode == 'Quasar' then
        spamming_done = false
        ReplicatedStorage.Remotes.PlrQuasared:FireServer(AutoParry.target.aim)
        task.delay(0.085, function()
            spamming_done = true
        end)
    end
end)

-- Gravity
ConnectionsManager['gravity'] = RunService.PostSimulation:Connect(function()
    if not workspace.CurrentCamera or not LocalPlayer.Character then
        return
    end
    local gravity_enabled = Config.gravity
    if not gravity_enabled then
        workspace.Gravity = 196.2
        return
    end
    local strength = Config.gravity_strength
    workspace.Gravity = 196.2 / (strength / 10)
end)

local function setupBillboardSystem()
    local billboardLabels = {}
    local maxBillboards = 15
    local count = 0
    local lastUpdate = 0
    local updateInterval = 0.2

    local function createBillboardGui(player)
        if player == Players.LocalPlayer then
            return
        end

        local character = player.Character
        if not character then
            return
        end

        local head = character:FindFirstChild("Head")
        if not head then
            return
        end

        local billboardGui = Instance.new("BillboardGui")
        billboardGui.Adornee = head
        billboardGui.Size = UDim2.new(0, 100, 0, 25)
        billboardGui.StudsOffset = Vector3.new(0, 2, 0)
        billboardGui.AlwaysOnTop = false
        billboardGui.Parent = head

        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        textLabel.TextSize = 6
        textLabel.BackgroundTransparency = 1
        textLabel.TextXAlignment = Enum.TextXAlignment.Center
        textLabel.TextYAlignment = Enum.TextYAlignment.Center
        textLabel.Parent = billboardGui
        billboardLabels[player] = textLabel

        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
        end
    end

    Players.PlayerRemoving:Connect(function(player)
        if billboardLabels[player] then
            billboardLabels[player].Parent.Parent:Destroy()
            billboardLabels[player] = nil
        end
    end)

    ConnectionsManager['ability_esp'] = RunService.Heartbeat:Connect(function()
        if tick() - lastUpdate < updateInterval then
            return
        end
        lastUpdate = tick()

        if not Config.ability_esp then
            for _, label in pairs(billboardLabels) do
                label.Visible = false
            end
            return
        end

        for player, label in pairs(billboardLabels) do
            local character = player.Character
            if not character or not character.Parent or character.Parent ~= workspace:FindFirstChild("Alive") then
                label.Visible = false
                continue
            end
            label.Visible = true
            local abilityName = player:GetAttribute("EquippedAbility") or ""
            label.Text = abilityName == "" and player.DisplayName or (player.DisplayName .. " [" .. abilityName .. "]")
        end
    end)

    for _, player in ipairs(Players:GetPlayers()) do
        if count >= maxBillboards then
            break
        end
        pcall(createBillboardGui, player)
        count += 1
    end

    Players.PlayerAdded:Connect(function(player)
        if count < maxBillboards then
            pcall(createBillboardGui, player)
            count += 1
        end
    end)
end

-- Personnel Detector
local staff_roles = { 'content creator', 'contributor', 'trial qa', 'tester', 'mod' }
Players.PlayerAdded:Connect(function(player)
    local is_friend = LocalPlayer:IsFriendsWith(player.UserId)
    if is_friend then
        WindUI:Notify({
            Title = "Friend Joined",
            Content = "Friend " .. player.Name .. " joined!",
            Duration = 4,
        })
    end
    local personnel_detector_enabled = Config.personnel_detector
    if not personnel_detector_enabled then
        return
    end
    local personnel_detector_auto_leave_enabled = Config.personnel_detector_auto_leave
    local player_role = tostring(player:GetRoleInGroup(12836673)):lower()
    local player_is_staff = table.find(staff_roles, player_role)
    if player_is_staff then
        if personnel_detector_auto_leave_enabled then
            game:Shutdown()
            return
        end
        WindUI:Notify({
            Title = "Personnel Detected",
            Content = "Personnel joined, " .. player.Name .. ", role " .. player_role .. ".",
            Duration = 30,
        })
    end
end)

ConnectionsManager['strafe'] = RunService.PostSimulation:Connect(function()
    if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
        return
    end
    local strafe_enabled = Config.strafe
    if not strafe_enabled then
        return
    end
    local strength = Config.strafe_speed
    local Humanoid = LocalPlayer.Character.Humanoid
    if not Humanoid or Humanoid.MoveDirection.Magnitude < 0 then
        return
    end
    LocalPlayer.Character:TranslateBy(LocalPlayer.Character.Humanoid.MoveDirection * math.max((strength / 15), 2) * RunService.Heartbeat:Wait() * 10)
end)

ConnectionsManager['ball_effects'] = workspace.Balls.ChildAdded:Connect(function(ball)
    if not ball:GetAttribute("realBall") then
        return
    end
    if Config.particle_emitter then
        if not ball:FindFirstChild("ParticleEmitter") then
            local emitter = Instance.new("ParticleEmitter")
            emitter.Name = "ParticleEmitter"
            emitter.Rate = 100
            emitter.Lifetime = NumberRange.new(0.5, 1)
            emitter.Speed = NumberRange.new(0, 1)
            emitter.Size = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0.5),
                NumberSequenceKeypoint.new(1, 0)
            })
            emitter.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(1, 1)
            })
            emitter.Parent = ball
        end
    end
    if Config.glow_effect then
        if not ball:FindFirstChild("BallGlow") then
            local glow = Instance.new("PointLight")
            glow.Name = "BallGlow"
            glow.Range = 15
            glow.Brightness = 2
            glow.Parent = ball
        end
    end
end)

ConnectionsManager['training_ball_effects'] = workspace.TrainingBalls.ChildAdded:Connect(function(ball)
    if not ball:GetAttribute("realBall") then
        return
    end
    if Config.particle_emitter then
        if not ball:FindFirstChild("ParticleEmitter") then
            local emitter = Instance.new("ParticleEmitter")
            emitter.Name = "ParticleEmitter"
            emitter.Rate = 100
            emitter.Lifetime = NumberRange.new(0.5, 1)
            emitter.Speed = NumberRange.new(0, 1)
            emitter.Size = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0.5),
                NumberSequenceKeypoint.new(1, 0)
            })
            emitter.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(1, 1)
            })
            emitter.Parent = ball
        end
    end
    if Config.glow_effect then
        if not ball:FindFirstChild("BallGlow") then
            local glow = Instance.new("PointLight")
            glow.Name = "BallGlow"
            glow.Range = 15
            glow.Brightness = 2
            glow.Parent = ball
        end
    end
end)

-- No Slow
ConnectionsManager['no_slow'] = RunService.PostSimulation:Connect(function()
    if not LocalPlayer.Character or not workspace.Alive:FindFirstChild(LocalPlayer.Name) or not LocalPlayer.Character:FindFirstChild('Humanoid') then
        return
    end
    local no_slow_enabled = Config.no_slow
    if not no_slow_enabled then
        return
    end
    if LocalPlayer.Character.Humanoid.WalkSpeed < 36 then
        LocalPlayer.Character.Humanoid.WalkSpeed = 36
    end
end)

-- Auto Rewards
task.defer(function()
    while task.wait(60) do
        local auto_rewards_enabled = Config.auto_rewards
        if auto_rewards_enabled then
            Player:claim_rewards()
        end
    end
end)

-- Night Mode
ConnectionsManager['night_mode'] = RunService.PostSimulation:Connect(function()
    local night_mode_enabled = Config.night_mode
    if not night_mode_enabled then
        if Lighting.ClockTime == 11.2 then
            return
        end
        create_animation(Lighting, TweenInfo.new(1.6), { ClockTime = 11.2 })
        return
    end
    if Lighting.ClockTime == 2.5 then
        return
    end
    create_animation(Lighting, TweenInfo.new(1.6), { ClockTime = 2.5 })
end)

-- Ball Handling
local is_respawned = false
workspace.Balls.ChildRemoved:Connect(function(child)
    is_respawned = false
    if child == AutoParry.ball.ball_entity then
        AutoParry.ball.ball_entity = nil
        AutoParry.ball.client_ball_entity = nil
        ConnectionsManager.disconnect('on_target_change')
        AutoParry.reset()
    end
end)

workspace.Balls.ChildAdded:Connect(function()
    if is_respawned then
        return
    end
    is_respawned = true
    local ball_properties = AutoParry.ball.properties
    ball_properties.respawn_time = tick()
    AutoParry.ball.ball_entity = AutoParry.get_ball()
    AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()
    ConnectionsManager['on_target_change'] = AutoParry.ball.ball_entity:GetAttributeChangedSignal('target'):Connect(function()
        if target == LocalPlayer.Name then
            ball_properties.cooldown = false
            return
        end
        ball_properties.cooldown = false
        ball_properties.old_speed = ball_properties.speed
        ball_properties.last_position = ball_properties.position
        ball_properties.parries += 1
        task.delay(0.25, function()
            if ball_properties.parries > 0 then
                ball_properties.parries -= 1
            end
        end)
    end)
end)

local function look_at(primary_part, position, delta, radians)
    local primary_part_pos = primary_part.Position
    local target_pos = position

    primary_part_pos = Vector3.new(primary_part_pos.X, 0, primary_part_pos.Z)
    target_pos = Vector3.new(target_pos.X, 0, target_pos.Z)

    local primary_part_look_vector = primary_part.CFrame.LookVector
    primary_part_look_vector = Vector3.new(primary_part_look_vector.X, 0, primary_part_look_vector.Z).unit

    local lerp_vector = primary_part_look_vector:Lerp((target_pos - primary_part_pos).unit, delta)

    if lerp_vector:Dot(primary_part_look_vector) < math.cos(math.rad(radians)) then
        lerp_vector = CFrame.Angles(0, math.rad(radians), 0) * primary_part_look_vector
    end

    primary_part.CFrame = CFrame.lookAt(primary_part.Position, primary_part.Position + lerp_vector)
end

ConnectionsManager['auto_parry_rotation'] = RunService.Stepped:Connect(function()
    local auto_parry_rotation_enabled = Config.auto_parry_rotation
    if not auto_parry_rotation_enabled or not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
        return
    end
    local humanoid = LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
    if not humanoid or humanoid.Health <= 0 or workspace.Dead:FindFirstChild(LocalPlayer.Name) then
        humanoid.AutoRotate = true
        return
    end
    local ball = AutoParry.get_ball()
    if not ball then
        return
    end
    local auto_parry_rotation_acuity_value = Config.auto_parry_rotation_acuity / 100
    local ball_properties = AutoParry.ball.properties
    if ball_properties.speed < 10 or ball_properties.distance < 20 + ball_properties.speed / 2 then
        look_at(LocalPlayer.Character.PrimaryPart, ball_properties.rotation, auto_parry_rotation_acuity_value / 2, 25)
        return
    end
    look_at(LocalPlayer.Character.PrimaryPart, ball_properties.rotation, auto_parry_rotation_acuity_value, 25)
end)

-- No Render
task.defer(function()
    workspace.Runtime.ChildAdded:Connect(function(child)
        local no_render_enabled = Config.no_render
        local smart_no_render_enabled = Config.smart_no_render
        local ability_vulnerability_enabled = Config.ability_vulnerability
        if no_render_enabled then
            if AutoParry.ball.properties.auto_spam then
                AutoParry:PerformParry()   
            end
            if smart_no_render_enabled and not ability_vulnerability_enabled and not AutoParry.ball.properties.auto_spam then
                LocalPlayer.PlayerScripts.EffectScripts.ClientFX.Enabled = true
                return
            end
            LocalPlayer.PlayerScripts.EffectScripts.ClientFX.Enabled = false
            if child.Name == 'Tornado' then
                return
            end
            Debris:AddItem(child, 0)
            return
        end
        LocalPlayer.PlayerScripts.EffectScripts.ClientFX.Enabled = true
    end)
end)


function ManualSpam()
    -- Services
    local CoreGui = game:GetService("CoreGui")
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")

    -- Variabel global
    if ManualSpamGui then
        local main = ManualSpamGui:FindFirstChild("Main")
        if main then
            -- Animasi keluar
            local shadow = main:FindFirstChild("Shadow")
            local indicator = main:FindFirstChild("Indicator")
            local speedLabel = main:FindFirstChild("SpeedLabel")
            local pc = main:FindFirstChild("PC")
            local spamButton = main:FindFirstChild("SpamButton")

            if main and shadow and indicator and speedLabel and pc and spamButton then
                local tweenInfo = TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.In)
                local tweens = {}
                tweens[#tweens + 1] = TweenService:Create(shadow, tweenInfo, {ImageTransparency = 1, Size = UDim2.new(1, 10, 1, 10)})
                tweens[#tweens + 1] = TweenService:Create(main, tweenInfo, {
                    BackgroundTransparency = 1,
                    Size = UDim2.new(0.182, 0, 0.153, 0),
                    Position = UDim2.new(0.414, 0, 0.304, 0),
                    Rotation = -10
                })
                tweens[#tweens + 1] = TweenService:Create(indicator, tweenInfo, {BackgroundTransparency = 1})
                tweens[#tweens + 1] = TweenService:Create(speedLabel, tweenInfo, {TextTransparency = 1})
                tweens[#tweens + 1] = TweenService:Create(pc, tweenInfo, {TextTransparency = 1})
                tweens[#tweens + 1] = TweenService:Create(spamButton, tweenInfo, {BackgroundTransparency = 1, TextTransparency = 1})

                local mainFadeOut = tweens[2] -- Tween untuk main
                for i, tween in ipairs(tweens) do
                    if tween then
                        tween:Play()
                    else
                        warn("Debug: Tween #" .. i .. " is nil")
                    end
                end

                if mainFadeOut then
                    mainFadeOut.Completed:Connect(function()
                        if ManualSpamGui then
                            ManualSpamGui:Destroy()
                            ManualSpamGui = nil
                        end
                    end)
                else
                    warn("Debug: mainFadeOut is nil, destroying GUI immediately")
                    if ManualSpamGui then
                        ManualSpamGui:Destroy()
                        ManualSpamGui = nil
                    end
                end
            else
                warn("Debug: One or more GUI elements are missing: main=" .. tostring(main) .. ", shadow=" .. tostring(shadow) .. ", indicator=" .. tostring(indicator) .. ", speedLabel=" .. tostring(speedLabel) .. ", pc=" .. tostring(pc) .. ", spamButton=" .. tostring(spamButton))
                if ManualSpamGui then
                    ManualSpamGui:Destroy()
                    ManualSpamGui = nil
                end
            end
        else
            warn("Debug: Main frame is nil")
            if ManualSpamGui then
                ManualSpamGui:Destroy()
                ManualSpamGui = nil
            end
        end

        manualSpamEnabled = false
        Config.manual_spam = false
        if manualSpamConnection then
            manualSpamConnection:Disconnect()
            manualSpamConnection = nil
        end
        if manualSpamKeyConnection then
            manualSpamKeyConnection:Disconnect()
            manualSpamKeyConnection = nil
        end
        if WindUI and WindUI.Notify then
            WindUI:Notify({
                Title = "Manual Spam",
                Content = "Manual Spam disabled",
                Duration = 0.5,
                Icon = "swords"
            })
        else
            print("Manual Spam: Disabled")
        end
        return
    end

    -- Buat ScreenGui
    ManualSpamGui = Instance.new("ScreenGui")
    ManualSpamGui.Name = "ManualSpamGui"
    ManualSpamGui.Parent = CoreGui
    ManualSpamGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ManualSpamGui.ResetOnSpawn = false

    -- Buat Frame utama
    local Main = Instance.new("Frame")
    Main.Name = "Main"
    Main.Parent = ManualSpamGui
    Main.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    Main.BackgroundTransparency = 1
    Main.BorderSizePixel = 0
    Main.Position = UDim2.new(0.414, 0, 0.304, 0)
    Main.Size = UDim2.new(0.182, 0, 0.153, 0)
    Main.Rotation = -10
    Main.ClipsDescendants = true

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 12)
    UICorner.Parent = Main

    local UIStroke = Instance.new("UIStroke")
    UIStroke.Color = Color3.fromRGB(255, 50, 50)
    UIStroke.Thickness = 1.5
    UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    UIStroke.Parent = Main

    local UIGradient = Instance.new("UIGradient")
    UIGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 25)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(50, 50, 50)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 25, 25))
    })
    UIGradient.Rotation = 45
    UIGradient.Parent = Main
    TweenService:Create(UIGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Offset = Vector2.new(1, 0)}):Play()

    local Shadow = Instance.new("ImageLabel")
    Shadow.Name = "Shadow"
    Shadow.Parent = Main
    Shadow.BackgroundTransparency = 1
    Shadow.Size = UDim2.new(1, 20, 1, 20)
    Shadow.Position = UDim2.new(0, -10, 0, -10)
    Shadow.Image = "rbxassetid://131604521"
    Shadow.ImageTransparency = 1
    Shadow.ZIndex = -1
    Shadow.ScaleType = Enum.ScaleType.Slice
    Shadow.SliceCenter = Rect.new(10, 10, 118, 118)

    local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint.AspectRatio = 1.667
    UIAspectRatioConstraint.Parent = Main

    -- Buat Indikator
    local Indicator = Instance.new("Frame")
    Indicator.Name = "Indicator"
    Indicator.Parent = Main
    Indicator.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
    Indicator.BackgroundTransparency = 1
    Indicator.BorderSizePixel = 0
    Indicator.Position = UDim2.new(0.028, 0, 0.073, 0)
    Indicator.Size = UDim2.new(0.072, 0, 0.12, 0)

    local UICorner_2 = Instance.new("UICorner")
    UICorner_2.CornerRadius = UDim.new(1, 0)
    UICorner_2.Parent = Indicator

    local IndicatorGradient = Instance.new("UIGradient")
    IndicatorGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 50, 50)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 100, 100)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 50, 50))
    })
    IndicatorGradient.Rotation = 45
    IndicatorGradient.Parent = Indicator
    TweenService:Create(IndicatorGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Offset = Vector2.new(1, 0)}):Play()

    local IndicatorGlow = Instance.new("UIStroke")
    IndicatorGlow.Color = Color3.fromRGB(255, 100, 100)
    IndicatorGlow.Thickness = 1
    IndicatorGlow.Transparency = 0.5
    IndicatorGlow.Parent = Indicator

    local UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_2.Parent = Indicator

    -- Buat TextLabel untuk kecepatan parry
    local SpeedLabel = Instance.new("TextLabel")
    SpeedLabel.Name = "SpeedLabel"
    SpeedLabel.Parent = Main
    SpeedLabel.BackgroundTransparency = 1
    SpeedLabel.Position = UDim2.new(0.164, 0, 0.073, 0)
    SpeedLabel.Size = UDim2.new(0.668, 0, 0.173, 0)
    SpeedLabel.Font = Enum.Font.GothamBold
    SpeedLabel.Text = "Spam Speed: 0/s"
    SpeedLabel.TextColor3 = Color3.fromRGB(230, 230, 230)
    SpeedLabel.TextTransparency = 1
    SpeedLabel.TextScaled = true
    SpeedLabel.TextWrapped = true
    SpeedLabel.TextStrokeTransparency = 0.7
    SpeedLabel.TextStrokeColor3 = Color3.fromRGB(255, 215, 0)

    local SpeedLabelGradient = Instance.new("UIGradient")
    SpeedLabelGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 215, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))
    })
    SpeedLabelGradient.Rotation = 45
    SpeedLabelGradient.Parent = SpeedLabel
    TweenService:Create(SpeedLabelGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Offset = Vector2.new(1, 0)}):Play()
    TweenService:Create(SpeedLabel, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {TextStrokeTransparency = 0.3}):Play()

    local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint.MaxTextSize = 18
    UITextSizeConstraint.Parent = SpeedLabel

    -- Buat TextLabel untuk petunjuk tombol
    local PC = Instance.new("TextLabel")
    PC.Name = "PC"
    PC.Parent = Main
    PC.BackgroundTransparency = 1
    PC.Position = UDim2.new(0.164, 0, 0.827, 0)
    PC.Size = UDim2.new(0.452, 0, 0.173, 0)
    PC.Font = Enum.Font.Gotham
    PC.Text = "Press E to toggle"
    PC.TextColor3 = Color3.fromRGB(180, 180, 180)
    PC.TextTransparency = 1
    PC.TextScaled = true
    PC.TextWrapped = true
    PC.TextStrokeTransparency = 0.7
    PC.TextStrokeColor3 = Color3.fromRGB(255, 215, 0)

    local UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint_2.MaxTextSize = 16
    UITextSizeConstraint_2.Parent = PC

    local UIAspectRatioConstraint_3 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_3.AspectRatio = 4.346
    UIAspectRatioConstraint_3.Parent = PC

    -- Buat Tombol Spam
    local SpamButton = Instance.new("TextButton")
    SpamButton.Name = "SpamButton"
    SpamButton.Parent = Main
    SpamButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    SpamButton.BackgroundTransparency = 1
    SpamButton.BorderSizePixel = 0
    SpamButton.Position = UDim2.new(0.164, 0, 0.327, 0)
    SpamButton.Size = UDim2.new(0.668, 0, 0.347, 0)
    SpamButton.Font = Enum.Font.GothamBold
    SpamButton.Text = "SPAM"
    SpamButton.TextColor3 = Color3.fromRGB(230, 230, 230)
    SpamButton.TextTransparency = 1
    SpamButton.TextScaled = true
    SpamButton.TextWrapped = true
    SpamButton.TextStrokeTransparency = 0.7
    SpamButton.TextStrokeColor3 = Color3.fromRGB(255, 215, 0)

    local UICorner_3 = Instance.new("UICorner")
    UICorner_3.CornerRadius = UDim.new(0, 8)
    UICorner_3.Parent = SpamButton

    local UIStroke_2 = Instance.new("UIStroke")
    UIStroke_2.Color = Color3.fromRGB(255, 50, 50)
    UIStroke_2.Thickness = 1.5
    UIStroke_2.Parent = SpamButton

    local ButtonGradient = Instance.new("UIGradient")
    ButtonGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(45, 45, 45)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(70, 70, 70)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(45, 45, 45))
    })
    ButtonGradient.Rotation = 45
    ButtonGradient.Parent = SpamButton
    TweenService:Create(ButtonGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Offset = Vector2.new(1, 0)}):Play()

    local UITextSizeConstraint_3 = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint_3.MaxTextSize = 26
    UITextSizeConstraint_3.Parent = SpamButton

    local UIAspectRatioConstraint_4 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_4.AspectRatio = 3.212
    UIAspectRatioConstraint_4.Parent = SpamButton

    
    local tweenInfo = TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
    TweenService:Create(Shadow, tweenInfo, {ImageTransparency = 0.7, Size = UDim2.new(1, 20, 1, 20)}):Play()
    TweenService:Create(Main, tweenInfo, {
        BackgroundTransparency = 0,
        Size = UDim2.new(0.227, 0, 0.191, 0),
        Position = UDim2.new(0.414, 0, 0.404, 0),
        Rotation = 0
    }):Play()
    TweenService:Create(Indicator, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out, 0, false, 0.2), {BackgroundTransparency = 0}):Play()
    TweenService:Create(SpeedLabel, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out, 0, false, 0.3), {TextTransparency = 0}):Play()
    TweenService:Create(PC, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out, 0, false, 0.3), {TextTransparency = 0}):Play()
    TweenService:Create(SpamButton, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out, 0, false, 0.4), {BackgroundTransparency = 0, TextTransparency = 0}):Play()

    -- Animasi dan pengaturan kecepatan parry
    local parrySpeed = 299
    local parryCount = 0
    local lastUpdate = tick()

    local function updateSpeedLabel()
        local elapsed = tick() - lastUpdate
        if elapsed >= 0.1 then
            local speed = math.round(parryCount / elapsed)
            SpeedLabel.Text = "Spam Speed: " .. speed .. "/s"
            parryCount = 0
            lastUpdate = tick()

            local tweenInfo = TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
            SpeedLabel.TextTransparency = 0.4
            TweenService:Create(SpeedLabel, tweenInfo, {TextTransparency = 0}):Play()
        end
    end

    local function pulseIndicator()
        local tweenInfo = TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
        TweenService:Create(Indicator, tweenInfo, {Size = UDim2.new(0.08, 0, 0.133, 0)}):Play()
        TweenService:Create(Indicator, tweenInfo, {BackgroundTransparency = 0.2}):Play()
        TweenService:Create(IndicatorGlow, tweenInfo, {Transparency = 0.3}):Play()
    end

    local function toggleSpam()
        manualSpamEnabled = not manualSpamEnabled
        Config.manual_spam = manualSpamEnabled

        if manualSpamConnection then
            manualSpamConnection:Disconnect()
            manualSpamConnection = nil
        end

        if manualSpamEnabled then
            UIStroke.Color = Color3.fromRGB(50, 255, 50)
            UIStroke_2.Color = Color3.fromRGB(50, 255, 50)
            Indicator.BackgroundColor3 = Color3.fromRGB(50, 255, 50)
            IndicatorGlow.Color = Color3.fromRGB(100, 255, 100)
            IndicatorGradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 255, 50)),
                ColorSequenceKeypoint.new(0.5, Color3.fromRGB(100, 255, 100)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 255, 50))
            })
            pulseIndicator()

            local lastParry = 0
            manualSpamConnection = RunService.Heartbeat:Connect(function(deltaTime)
                if not manualSpamEnabled then return end
                local parriesPerFrame = parrySpeed * deltaTime
                local parryCountThisFrame = math.floor(parriesPerFrame)
                local remainder = parriesPerFrame - parryCountThisFrame
                if remainder >= math.random() then
                    parryCountThisFrame = parryCountThisFrame + 1
                end

                for i = 1, parryCountThisFrame do
                    local success, err = pcall(function()
                        if AutoParry and AutoParry.ExecuteParry and type(AutoParry.ExecuteParry) == "function" then
                            task.spawn(AutoParry.ExecuteParry)
                        else
                            warn("AutoParry or ExecuteParry is not a valid function")
                        end
                    end)
                    if success then
                        parryCount = parryCount + 1
                    else
                        warn("Error in AutoParry:ExecuteParry:", err)
                    end
                end
                updateSpeedLabel()
            end)
        else
            UIStroke.Color = Color3.fromRGB(255, 50, 50)
            UIStroke_2.Color = Color3.fromRGB(255, 50, 50)
            Indicator.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
            IndicatorGlow.Color = Color3.fromRGB(255, 100, 100)
            IndicatorGradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 50, 50)),
                ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 100, 100)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 50, 50))
            })
            Indicator.Size = UDim2.new(0.072, 0, 0.12, 0)
            Indicator.BackgroundTransparency = 0
            IndicatorGlow.Transparency = 0.5
        end

        local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
        TweenService:Create(SpamButton, tweenInfo, {
            Size = manualSpamEnabled and UDim2.new(0.7, 0, 0.36, 0) or UDim2.new(0.668, 0, 0.347, 0),
            BackgroundColor3 = manualSpamEnabled and Color3.fromRGB(50, 50, 50) or Color3.fromRGB(45, 45, 45)
        }):Play()
        TweenService:Create(UIStroke_2, tweenInfo, {
            Color = manualSpamEnabled and Color3.fromRGB(50, 255, 50) or Color3.fromRGB(255, 50, 50)
        }):Play()

        if WindUI and WindUI.Notify then
            WindUI:Notify({
                Title = "Manual Spam",
                Content = "Manual Spam " .. (manualSpamEnabled and "enabled" or "disabled"),
                Duration = 0.5,
                Icon = "swords"
            })
        else
            print("Manual Spam: " .. (manualSpamEnabled and "enabled" or "disabled"))
        end
    end

    -- Animasi hover
    SpamButton.MouseEnter:Connect(function()
        local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
        TweenService:Create(SpamButton, tweenInfo, {
            Size = UDim2.new(0.7, 0, 0.36, 0),
            BackgroundColor3 = Color3.fromRGB(55, 55, 55)
        }):Play()
        TweenService:Create(UIStroke_2, tweenInfo, {
            Thickness = 2,
            Color = manualSpamEnabled and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
        }):Play()
    end)

    SpamButton.MouseLeave:Connect(function()
        local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
        TweenService:Create(SpamButton, tweenInfo, {
            Size = UDim2.new(0.668, 0, 0.347, 0),
            BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        }):Play()
        TweenService:Create(UIStroke_2, tweenInfo, {
            Thickness = 1.5,
            Color = manualSpamEnabled and Color3.fromRGB(50, 255, 50) or Color3.fromRGB(255, 50, 50)
        }):Play()
    end)

    SpamButton.MouseButton1Down:Connect(function()
        local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
        TweenService:Create(SpamButton, tweenInfo, {Size = UDim2.new(0.65, 0, 0.34, 0)}):Play()
    end)

    SpamButton.MouseButton1Up:Connect(function()
        local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        TweenService:Create(SpamButton, tweenInfo, {Size = UDim2.new(0.668, 0, 0.347, 0)}):Play()
    end)

    SpamButton.MouseButton1Click:Connect(toggleSpam)

    manualSpamKeyConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.E then
            toggleSpam()
        end
    end)

    ManualSpamGui.Destroying:Connect(function()
        if manualSpamKeyConnection then
            manualSpamKeyConnection:Disconnect()
            manualSpamKeyConnection = nil
        end
        if manualSpamConnection then
            manualSpamConnection:Disconnect()
            manualSpamConnection = nil
        end
    end)

    -- Draggable GUI
    local gui = Main
    local dragging
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        local newPosition = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
        TweenService:Create(gui, TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Position = newPosition}):Play()
    end

    gui.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = gui.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    gui.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input == dragInput then
            update(input)
        end
    end)

    if WindUI and WindUI.Notify then
        WindUI:Notify({
            Title = "Manual Spam",
            Content = "Manual Spam GUI enabled",
            Duration = 0.5,
            Icon = "swords"
        })
    else
        print("Manual Spam: GUI enabled")
    end
end

task.delay(30, function()
    local player_ping = Player.Entity.properties.ping
    if player_ping > 100 and player_ping < 200 then
        WindUI:Notify({
            Title = "[Detect Warning]",
            Content = "Low connection speed, delays may occur.",
            Duration = 15,
        })
    elseif player_ping >= 200 then
        WindUI:Notify({
            Title = "[Detect Critical Warning]",
            Content = "Critically slow connection speed, delays ensured.",
            Duration = 15,
        })
    end
end)
